<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <link rel="manifest" href="manifest.json">

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon" href="icon-192.png">

    <script>
      if ("serviceWorker" in navigator) {
        navigator.serviceWorker.register("sw.js");
      }
    </script>

   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
   <title>æ’­æ£‹ Mancala</title>
   <style>
       :root {
           --bg-color: #121212;
           --container-bg: #1e1e1e;
           --pit-bg: #2a2a2a;
           --pit-border: 2px solid #333;
           --neon-1: #00E5FF;
           --neon-2: #FF4081;
           --neon-3: #FFEA00;
           --text-color: #E0E0E0;
           --accent-color: #1e1e1e;
       }

       body {
           margin: 0;
           padding: 0;
           font-family: 'Noto Sans TC','Segoe UI', Roboto, "Microsoft JhengHei", sans-serif;
           background-color: var(--bg-color);
           color: var(--text-color);
           display: flex;
           justify-content: center;
           align-items: center;
           min-height: 100vh;
           overflow: hidden;
           user-select: none;
           -webkit-user-select: none;
           touch-action: manipulation;
           background-image: radial-gradient(circle at 10% 20%, rgba(124, 77, 255, 0.1) 0%, transparent 20%),
                             radial-gradient(circle at 90% 80%, rgba(0, 229, 255, 0.1) 0%, transparent 20%);
       }

       .game-container {
           position: relative;
           width: 95vw;
           max-width: 900px;
           background: var(--container-bg);
           border-radius: 30px;
           box-shadow: 0 30px 60px rgba(0,0,0,0.6);
           padding: 30px;
           display: flex;
           flex-direction: column;
           align-items: center;
           border: 1px solid #333;
           box-sizing: border-box;
       }

       .header {
           width: 100%;
           display: flex;
           justify-content: space-between;
           align-items: center;
           margin-bottom: 20px;
           z-index: 10;
       }

       .controls-left, .controls-right {
           display: flex;
           gap: 10px;
           flex-wrap: wrap;
       }

       .btn {
           background: rgba(255, 255, 255, 0.05);
           backdrop-filter: blur(10px);
           -webkit-backdrop-filter: blur(10px);
           border: 1px solid rgba(255, 255, 255, 0.1);
           color: var(--text-color);
           padding: 10px 15px;
           border-radius: 12px;
           cursor: pointer;
           font-weight: 600;
           transition: all 0.3s ease;
           display: flex;
           align-items: center;
           justify-content: center;
           box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
           text-shadow: 0 1px 2px rgba(0,0,0,0.8); 
           white-space: nowrap;
           font-size: 0.9rem;
       }

       .btn:hover:not(:disabled) {
           background: rgba(255, 255, 255, 0.15);
           border-color: rgba(255, 255, 255, 0.3);
           transform: translateY(-2px);
           box-shadow: 0 8px 15px rgba(0, 0, 0, 0.2);
           color: #fff;
       }

       .btn:disabled {
           opacity: 0.3;
           cursor: not-allowed;
           transform: none;
           background: rgba(0,0,0,0.2);
           box-shadow: none;
           border-color: #333;
       }
       
       /* æ•™å­¸æŒ‰éˆ•æ¨£å¼ */
       .btn-tutorial {
           background: linear-gradient(135deg, var(--neon-1) 0%, #2979FF 100%);
           border: none;
           color: #fff;
           font-weight: 800;
           width: 100%;
           margin-top: 15px;
           padding: 15px;
       }
       .btn-tutorial:hover:not(:disabled) {
           background: linear-gradient(135deg, #40c4ff 0%, #448aff 100%);
           transform: translateY(-2px);
           box-shadow: 0 0 20px rgba(0, 229, 255, 0.4);
       }
       .btn-tutorial:disabled {
           background: #444;
           color: #888;
           box-shadow: none;
           cursor: not-allowed;
           transform: none;
       }

       /* ä¸‹æ‹‰é¸å–®æ¨£å¼å„ªåŒ– */
       select.btn {
           appearance: none;
           padding-right: 30px;
           background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23ffffff'%3E%3Cpath d='M7 10l5 5 5-5z'/%3E%3C/svg%3E");
           background-repeat: no-repeat;
           background-position: right 8px center;
           background-size: 16px;
       }
       select.btn option {
           background-color: #252525;
           color: #fff;
       }
       
       select#difficulty-select {
           border-color: rgba(255, 255, 255, 0.1); /* Default border */
           font-weight: bold;
       }

       .turn-indicator {
           font-size: 1.2rem;
           font-weight: bold;
           color: #fff;
           padding: 10px 30px;
           background: rgba(255, 255, 255, 0.03);
           backdrop-filter: blur(10px);
           border-radius: 50px;
           border: 1px solid rgba(255, 255, 255, 0.1);
           min-width: 150px;
           text-align: center;
           position: relative;
           overflow: hidden;
           box-shadow: 0 4px 15px rgba(0,0,0,0.2);
           transition: all 0.3s;
       }

       .turn-indicator::after {
           content: '';
           position: absolute;
           bottom: 0; left: 0; width: 100%; height: 2px;
           background: linear-gradient(90deg, transparent, var(--neon-1), var(--neon-2), transparent);
           transform: scaleX(0);
           transition: transform 0.4s ease;
       }

       .turn-indicator.active {
           border-color: rgba(255, 255, 255, 0.2);
       }
       .turn-indicator.active::after {
           transform: scaleX(1);
       }

       .board {
           display: flex;
           justify-content: space-between;
           align-items: stretch;
           background: #222;
           padding: 25px;
           border-radius: 30px;
           width: 100%;
           box-sizing: border-box;
           gap: 20px;
           position: relative;
       }

       .store {
           width: 100px;
           min-height: 180px;
           background: var(--pit-bg);
           border-radius: 25px;
           border: var(--pit-border);
           display: flex;
           flex-direction: column;
           justify-content: center;
           align-items: center;
           position: relative;
           transition: all 0.3s;
       }
       
       .store.highlight-turn {
           border-color: rgba(255, 255, 255, 0.5);
           box-shadow: 0 0 20px rgba(255, 255, 255, 0.05);
           background: #333;
       }

       .pits-area {
           flex: 1;
           display: flex;
           flex-direction: column;
           justify-content: space-between;
           gap: 25px;
       }

       .row {
           display: flex;
           justify-content: space-around;
           gap: 5px;
       }

       .pit {
           width: 80px;
           height: 80px;
           background: var(--pit-bg);
           border-radius: 50%;
           border: var(--pit-border);
           display: flex;
           justify-content: center;
           align-items: center;
           cursor: pointer;
           position: relative;
           transition: all 0.2s;
       }

       /* å‘¼å¸ç‡ˆå‹•ç•« */
       @keyframes breathing-glow {
           0% { box-shadow: 0 0 0px rgba(255, 255, 255, 0); border-color: #333; }
           50% { box-shadow: 0 0 15px rgba(255, 255, 255, 0.4); border-color: rgba(255, 255, 255, 0.6); }
           100% { box-shadow: 0 0 0px rgba(255, 255, 255, 0); border-color: #333; }
       }

       /* ç•¶å‰å›åˆç©å®¶çš„å‘æ´ç™¼å…‰ Class */
       .pit.active-turn-glow {
           animation: breathing-glow 2s infinite ease-in-out;
           z-index: 5;
       }
       
       /* æ•™å­¸æ¨¡å¼æŒ‡å¼• */
       .pit.tutorial-target {
           animation: breathing-glow 1s infinite ease-in-out !important;
           border-color: var(--neon-3) !important;
           box-shadow: 0 0 20px var(--neon-3) !important;
           z-index: 100;
       }

       .pit:hover:not(.disabled) {
           background: #333;
           transform: translateY(-2px);
           border-color: var(--neon-1);
           box-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
       }
       
       .pit.capture-flash {
           animation: flashHighlight 0.5s ease !important; /* å¼·åˆ¶è¦†è“‹å‘¼å¸ç‡ˆ */
       }

       @keyframes flashHighlight {
           0% { background-color: var(--pit-bg); box-shadow: 0 0 0 transparent; }
           50% { background-color: #444; box-shadow: 0 0 20px var(--neon-2); border-color: var(--neon-2); }
           100% { background-color: var(--pit-bg); box-shadow: 0 0 0 transparent; }
       }

       .pit.disabled {
           cursor: default;
           opacity: 0.7;
           animation: none; /* ç¦ç”¨æ™‚ä¸ç™¼å…‰ */
       }

       .seed-count-badge {
           position: absolute;
           top: -8px;
           right: -8px;
           width: 26px;
           height: 26px;
           background: #3a3a3a;
           color: #fff;
           border-radius: 50%;
           font-size: 0.9rem;
           font-weight: bold;
           display: flex;
           justify-content: center;
           align-items: center;
           box-shadow: 0 2px 5px rgba(0,0,0,0.3);
           z-index: 6;
           border: 1px solid #555;
           transition: transform 0.2s;
       }
       
       .seeds-container {
           width: 65%;
           height: 65%;
           display: flex;
           flex-wrap: wrap;
           justify-content: center;
           align-items: center;
           gap: 4px;
           pointer-events: none;
       }

       .seed {
           width: 12px;
           height: 12px;
           border-radius: 50%;
           background-color: var(--neon-1);
           box-shadow: 0 0 4px rgba(0, 229, 255, 0.6); 
       }
       .seed:nth-child(2n) { background-color: var(--neon-2); box-shadow: 0 0 4px rgba(255, 64, 129, 0.6); }
       .seed:nth-child(3n) { background-color: var(--neon-3); box-shadow: 0 0 4px rgba(255, 234, 0, 0.6); }

       .label {
           position: absolute;
           color: #aaa;
           font-size: 0.85rem;
           text-transform: uppercase;
           letter-spacing: 1px;
           font-weight: 600;
           text-align: center;
           width: 100%;
       }
       .store.top .label { bottom: 15px; }
       .store.bottom .label { top: 15px; }

       #center-message {
           position: absolute;
           top: 50%;
           left: 50%;
           transform: translate(-50%, -50%);
           font-size: 3.5rem;
           color: #FFF;
           font-weight: 900;
           text-shadow: 0 4px 10px rgba(0,0,0,0.8);
           pointer-events: none;
           z-index: 100;
           opacity: 0;
           transition: opacity 0.3s;
           text-align: center;
           width: 100%;
           letter-spacing: 3px;
           white-space: nowrap;
       }

       .flying-seed {
           position: fixed;
           width: 14px;
           height: 14px;
           background-color: #fff;
           border-radius: 50%;
           z-index: 999;
           pointer-events: none;
           box-shadow: 0 0 10px #fff;
           transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
       }
       
       .ai-bubble {
           position: absolute;
           top: -60px;
           left: 50%;
           transform: translateX(-50%);
           background: rgba(0, 0, 0, 0.8);
           border: 1px solid var(--neon-2);
           color: var(--neon-2);
           padding: 10px 15px;
           border-radius: 15px;
           border-bottom-left-radius: 0;
           font-size: 0.9rem;
           min-width: 150px;
           text-align: center;
           box-shadow: 0 0 15px rgba(255, 64, 129, 0.3);
           opacity: 0;
           transition: opacity 0.5s;
           pointer-events: none;
           z-index: 50;
       }
       .ai-bubble.visible { opacity: 1; }

       .modal {
           display: none;
           position: fixed;
           top: 0; left: 0; width: 100%; height: 100%;
           background: rgba(0,0,0,0.85);
           backdrop-filter: blur(8px);
           z-index: 200;
           justify-content: center;
           align-items: center;
       }

       .modal-content {
           background: #252525;
           padding: 35px;
           border-radius: 20px;
           max-width: 500px;
           width: 90%;
           box-shadow: 0 10px 40px rgba(0,0,0,0.5);
           border: 1px solid #444;
           position: relative;
           color: #ddd;
           text-align: center;
           /* æ²å‹•è¨­å®š */
           max-height: 80vh;
           overflow-y: auto;
           scrollbar-width: thin;
           scrollbar-color: #555 #222;
       }

       .modal-content::-webkit-scrollbar {
           width: 8px;
       }
       .modal-content::-webkit-scrollbar-track {
           background: #222;
           border-radius: 4px;
       }
       .modal-content::-webkit-scrollbar-thumb {
           background: #555;
           border-radius: 4px;
       }

       .modal h2 {
           color: var(--neon-1);
           margin-top: 0;
           border-bottom: 1px solid #444;
           padding-bottom: 15px;
           margin-bottom: 20px;
           text-align: left;
           position: sticky;
           top: -35px; /* æŠµéŠ· padding */
           background: #252525;
           z-index: 10;
           padding-top: 10px;
       }
       
       .modal-content.centered-text h2 {
           text-align: center;
       }

       .close-btn {
           position: absolute;
           top: 15px;
           right: 20px;
           font-size: 28px;
           cursor: pointer;
           color: #888;
           transition: color 0.2s;
           z-index: 20;
       }
       .close-btn:hover { color: #fff; }
       
       .selection-btn-container {
           display: flex;
           gap: 15px;
           justify-content: center;
           margin-top: 25px;
       }
       
       .selection-btn-container .btn {
           min-width: 120px;
           font-size: 1.1rem;
       }

       /* è¦å‰‡åˆ—è¡¨æ¨£å¼ */
       .rules-list {
           text-align: left;
           line-height: 1.6;
           padding-left: 20px;
           margin-bottom: 25px;
       }
       .rules-list li {
           margin-bottom: 10px;
       }
       .rules-list strong {
           color: var(--neon-3);
       }

       @media (max-width: 1024px) {
           .game-container { padding: 20px; width: 98vw; }
           .pit { width: 60px; height: 60px; }
           .store { width: 80px; }
       }

       @media (max-width: 768px) {
           .game-container { padding: 10px; border-radius: 15px; border: none; box-shadow: none; }
           .header { flex-direction: column; gap: 10px; margin-bottom: 10px; }
           .controls-left, .controls-right { width: 100%; justify-content: center; gap: 8px; }
           .turn-indicator { width: 90%; padding: 8px 10px; min-width: auto; font-size: 1rem; }
           .board { padding: 8px; gap: 5px; border-radius: 15px; }
           .pits-area { gap: 8px; }
           .pit { width: 11.5vw; height: 11.5vw; max-width: 50px; max-height: 50px; }
           .store { width: 13vw; max-width: 60px; min-height: auto; height: auto; border-radius: 15px; }
           .label { font-size: 0.7rem; }
           .seed { width: 6px; height: 6px; }
           .seed-count-badge { width: 18px; height: 18px; font-size: 0.7rem; }
           .btn { padding: 8px 12px; font-size: 0.85rem; border-radius: 10px; }
           #center-message { font-size: 1.8rem; white-space: normal; width: 90%; line-height: 1.3; }
           .ai-bubble { top: auto; bottom: 110%; left: 0; transform: none; width: 150px; }
           .modal-content { padding: 25px; width: 85%; }
       }
   </style>
</head>
<body>

   <div class="game-container">
       <!-- é ‚éƒ¨è³‡è¨Šåˆ— -->
       <div class="header">
           <div class="controls-left">
               <button class="btn" onclick="toggleRules()">
                   <span style="font-size: 1em;">è¦å‰‡</span>
               </button>
               <select id="mode-select" class="btn" onchange="prepareGame()">
                   <option value="pve">å–®äººç·´ç¿’</option>
                   <option value="pvp">é›™äººå°æˆ°</option>
               </select>
               <!-- é›£åº¦é¸æ“‡ (åƒ… PVE é¡¯ç¤º) -->
               <select id="difficulty-select" class="btn" onchange="updateDifficultyStyle(); prepareGame()">
                   <option value="easy">é›£åº¦ï¼šç°¡å–®</option>
                   <option value="normal" selected>é›£åº¦ï¼šæ™®é€š</option>
                   <option value="hard">é›£åº¦ï¼šå›°é›£</option>
                   <option value="expert">é›£åº¦ï¼šå°ˆå®¶</option>
                   <option value="special">é›£åº¦ï¼šç‰¹åˆ¥</option>
               </select>
           </div>

           <div id="turn-display" class="turn-indicator active">
               éŠæˆ²æº–å‚™ä¸­
           </div>

           <div class="controls-right">
               <button id="undo-btn" class="btn" onclick="undoMove()" disabled>
                   <span style="font-size: 1em;">ä¸Šä¸€æ­¥</span>
               </button>
               <button id="reset-btn" class="btn" onclick="prepareGame()">
                   <span style="font-size: 1em;">é‡ç½®</span>
               </button>
           </div>
       </div>

       <!-- éŠæˆ²æ£‹ç›¤ -->
       <div class="board">
           <!-- ç©å®¶ 2 (NPC) çš„è¨ˆåˆ†æ´ -->
           <div class="store top" id="store-13">
               <div class="label" id="label-p2" style="top:15px;">é›»è…¦</div>
               <div class="seed-count-badge">0</div>
               <div class="seeds-container"></div>
               <!-- å°è©±æ°£æ³¡ -->
               <div id="npc-bubble" class="ai-bubble">example message</div>
           </div>

           <div class="pits-area">
               <!-- ç©å®¶ 2 çš„å‘æ´ (ä¸Šæ–¹ï¼Œç´¢å¼• 12 -> 7) -->
               <div class="row" id="row-p2">
                   <div class="pit" data-id="12"><div class="seed-count-badge">4</div><div class="seeds-container"></div></div>
                   <div class="pit" data-id="11"><div class="seed-count-badge">4</div><div class="seeds-container"></div></div>
                   <div class="pit" data-id="10"><div class="seed-count-badge">4</div><div class="seeds-container"></div></div>
                   <div class="pit" data-id="9"><div class="seed-count-badge">4</div><div class="seeds-container"></div></div>
                   <div class="pit" data-id="8"><div class="seed-count-badge">4</div><div class="seeds-container"></div></div>
                   <div class="pit" data-id="7"><div class="seed-count-badge">4</div><div class="seeds-container"></div></div>
               </div>

               <!-- ç©å®¶ 1 çš„å‘æ´ (ä¸‹æ–¹ï¼Œç´¢å¼• 0 -> 5) -->
               <div class="row" id="row-p1">
                   <div class="pit" data-id="0"><div class="seed-count-badge">4</div><div class="seeds-container"></div></div>
                   <div class="pit" data-id="1"><div class="seed-count-badge">4</div><div class="seeds-container"></div></div>
                   <div class="pit" data-id="2"><div class="seed-count-badge">4</div><div class="seeds-container"></div></div>
                   <div class="pit" data-id="3"><div class="seed-count-badge">4</div><div class="seeds-container"></div></div>
                   <div class="pit" data-id="4"><div class="seed-count-badge">4</div><div class="seeds-container"></div></div>
                   <div class="pit" data-id="5"><div class="seed-count-badge">4</div><div class="seeds-container"></div></div>
               </div>
           </div>

           <!-- ç©å®¶ 1 çš„è¨ˆåˆ†æ´ (å³å´) -->
           <div class="store bottom" id="store-6">
               <div class="label" id="label-p1" style="bottom:15px;">ç©å®¶ 1</div>
               <div class="seed-count-badge">0</div>
               <div class="seeds-container"></div>
           </div>
       </div>

       <div id="center-message"></div>
   </div>

   <!-- è¦å‰‡èˆ‡æ•™å­¸å½ˆçª— -->
   <div id="rules-modal" class="modal">
       <div class="modal-content">
           <span class="close-btn" onclick="toggleRules()">Ã—</span>
           <h2>ğŸ“– æ’­æ£‹ (Mancala) è¦å‰‡</h2>
           <div style="text-align: left;">
               <p><strong>ç›®æ¨™ï¼š</strong> éŠæˆ²çµæŸæ™‚ï¼Œå·±æ–¹è¨ˆåˆ†æ´ï¼ˆå¤§æ´ï¼‰å…§çš„æ£‹å­æ¯”å°æ‰‹å¤šã€‚</p>
               <ul class="rules-list">
                   <li><strong>ç§»å‹•ï¼š</strong> é»æ“Šå·±æ–¹å°æ´ï¼Œå–å‡ºæ‰€æœ‰æ£‹å­ï¼Œé€†æ™‚é‡ä¾åºæ’­æ’’ã€‚</li>
                   <li><strong>è¨ˆåˆ†æ´ï¼š</strong> ç¶“éè‡ªå·±è¨ˆåˆ†æ´æ™‚æœƒæ”¾å…¥ä¸€é¡†ï¼Œç¶“éå°æ‰‹çš„å‰‡è·³éã€‚</li>
                   <li><strong>å†ä¾†ä¸€æ¬¡ï¼š</strong> æœ€å¾Œä¸€é¡†è½å…¥è‡ªå·±çš„è¨ˆåˆ†æ´ï¼Œå¯é¡å¤–ç²å¾—ä¸€å›åˆã€‚</li>
                   <li><strong>æ•ç²ï¼š</strong> æœ€å¾Œä¸€é¡†è½å…¥å·±æ–¹ç©ºæ´ä¸”å°é¢æœ‰æ£‹å­ï¼Œå…©é‚Šæ£‹å­éƒ½æ”¾å…¥å¤§æ´ã€‚</li>
                   <li><strong>çµæŸï¼š</strong> ä¸€æ–¹æ¸…ç©ºæ‰€æœ‰å°æ´æ™‚çµæŸï¼Œå°æ‰‹å‰©é¤˜æ£‹å­æ­¸å°æ‰‹æ‰€æœ‰ã€‚</li>
               </ul>
           </div>
           
           <hr style="border: 0; border-top: 1px solid #444; margin: 20px 0;">
           
           <p style="color: #ccc; font-size: 0.9em; margin-bottom: 15px;">é‚„ä¸ç†Ÿæ‚‰è¦å‰‡å—ï¼Ÿè©¦è©¦çœ‹æ•™å­¸ï¼</p>
           <button id="start-tutorial-btn" class="btn btn-tutorial" onclick="startTutorial()">ğŸ“ é–‹å§‹æ•™å­¸æ¨¡å¼</button>
       </div>
   </div>

   <!-- PVE å…ˆæ‰‹é¸æ“‡å½ˆçª— -->
   <div id="turn-selection-modal" class="modal">
       <div class="modal-content centered-text">
           <span class="close-btn" onclick="closeTurnSelection()">Ã—</span>
           <h2>èª°å…ˆé–‹å§‹ï¼Ÿ</h2>
           <div class="selection-btn-container">
               <button class="btn" onclick="startGameWithPlayer(1)">ç©å®¶å…ˆæ‰‹</button>
               <button class="btn" onclick="startGameWithPlayer(2)">é›»è…¦å…ˆæ‰‹</button>
           </div>
       </div>
   </div>

   <script>
       const TOTAL_PITS = 14;
       const P1_STORE = 6;
       const P2_STORE = 13;
       const INITIAL_SEEDS = 4;
       
       let board = [];
       let currentPlayer = 1;
       let gameActive = false;
       let isAnimating = false;
       let gameMode = 'pve'; // pve, pvp, tutorial
       let aiDifficulty = 'normal';
       let activeGameDifficulty = 'normal';
       let historyStack = [];
       
       // æ•™å­¸æ¨¡å¼è®Šæ•¸
       let tutorialStep = 0;
       let tutorialTarget = -1; // ç•¶å‰å…è¨±é»æ“Šçš„å‘æ´
       let tutorialPhase = null; // ç”¨æ–¼ç®¡ç†æ•™å­¸æ­¥é©Ÿå…§çš„å­ç‹€æ…‹

       function init() {
           document.querySelectorAll('.pit').forEach(pit => {
               pit.addEventListener('click', () => handlePitClick(parseInt(pit.dataset.id)));
           });
           updateDifficultyStyle(); 
           prepareGame(); 
       }
       
       function updateDifficultyStyle() {
           const select = document.getElementById('difficulty-select');
           const val = select.value;
           let color = '#fff';
           
           if (val === 'easy') color = '#2979FF';
           else if (val === 'normal') color = '#0be00f';
           else if (val === 'hard') color = '#FFC107';
           else if (val === 'expert') color = '#FF5252';
           else if (val === 'special') color = '#FF4081';
           
           select.style.color = color;
       }

       function prepareGame() {
           const modeSelector = document.getElementById('mode-select');
           const diffSelector = document.getElementById('difficulty-select');
           gameMode = modeSelector.value;
           aiDifficulty = diffSelector.value;
           
           diffSelector.style.display = gameMode === 'pve' ? 'block' : 'none';

           if (gameMode === 'pve') {
               document.getElementById('turn-selection-modal').style.display = 'flex';
               updateControlsState(); 
           } else {
               const randomStarter = Math.random() < 0.5 ? 1 : 2;
               startGameWithPlayer(randomStarter);
           }
       }

       function closeTurnSelection() {
           document.getElementById('turn-selection-modal').style.display = 'none';
           if (document.getElementById('difficulty-select').value !== activeGameDifficulty) {
               document.getElementById('difficulty-select').value = activeGameDifficulty;
               aiDifficulty = activeGameDifficulty;
               updateDifficultyStyle();
           }
       }
       
       /* -------------- æ•™å­¸æ¨¡å¼é‚è¼¯ -------------- */
       
       function startTutorial() {
           if (isAnimating) return; // é˜²å‘†
           
           toggleRules(); // é—œé–‰è¦å‰‡çª—
           gameMode = 'tutorial';
           tutorialStep = 1;
           tutorialPhase = null;
           gameActive = true;
           isAnimating = false;
           currentPlayer = 1;
           historyStack = [];
           
           // UI è¨­å®š
           document.getElementById('label-p1').innerText = "ä½ ";
           document.getElementById('label-p2').innerText = "é›»è…¦";
           document.getElementById('turn-display').innerText = "æ•™å­¸æ¨¡å¼";
           document.getElementById('turn-display').style.color = "var(--neon-3)";
           
           setupTutorialStep(1);
           updateControlsState();
       }
       
       function setupTutorialStep(step) {
           tutorialStep = step;
           currentPlayer = 1; // ç¢ºä¿æ¯å€‹æ­¥é©Ÿéƒ½ç”±ç©å®¶é–‹å§‹
           tutorialPhase = null;

           if (step === 1) {
               // æ­¥é©Ÿ 1: åŸºç¤æ’­æ£‹
               board = Array(TOTAL_PITS).fill(0);
               board[2] = 5; 
               // è£é£¾ç”¨ï¼Œé¿å…å¤ªå–®èª¿
               board[0] = 1; board[1] = 2;
               board[8] = 2; board[9] = 2;
               
               tutorialTarget = 2;
               showMessage("èª²ç¨‹ 1ï¼šæ’­æ£‹", 3000, "é»æ“Šå·±æ–¹å‘æ´ï¼Œæ£‹å­å°‡é€†æ™‚é‡ä¾åºæ’­æ’’ï¼ˆæœƒç•¥éå°æ‰‹çš„è¨ˆåˆ†æ´ï¼‰");
           } else if (step === 2) {
               // æ­¥é©Ÿ 2: å†ä¾†ä¸€æ¬¡ (Free Turn)
               board = Array(TOTAL_PITS).fill(1); // å…¨å¡«1
               board[P1_STORE] = 2; // å…ˆçµ¦ä¸€é»åˆ†
               board[P2_STORE] = 2;
               board[5] = 1; // ç›®æ¨™
               board[7] = 0; 
               
               tutorialTarget = 5;
               showMessage("èª²ç¨‹ 2ï¼šå†ä¾†ä¸€æ¬¡", 3000, "è‹¥æœ€å¾Œä¸€é¡†è½åœ¨è¨ˆåˆ†æ´ï¼Œå¯å†è¡Œå‹•ä¸€æ¬¡");
           } else if (step === 3) {
               // æ­¥é©Ÿ 3: æ•ç² (Capture)
               board = Array(TOTAL_PITS).fill(2); // èƒŒæ™¯é›œè¨Š
               board[P1_STORE] = 5; 
               board[P2_STORE] = 5;
               board[0] = 1; // ç›®æ¨™
               board[1] = 0; // è½é» (ç©º)
               board[11] = 5; // è¢«æ•ç²å°è±¡
               
               tutorialTarget = 0;
               showMessage("èª²ç¨‹ 3ï¼šæ•ç²", 3000, "è½åœ¨å·±æ–¹ç©ºæ´æ™‚å¯æ•ç²å°é¢æ£‹å­");
           } else if (step === 4) {
               // æ­¥é©Ÿ 4: çµæŸéŠæˆ²
               board = Array(TOTAL_PITS).fill(0);
               board[5] = 1;
               // å°æ‰‹æœ‰å¾ˆå¤šæ£‹å­ï¼Œå±•ç¤ºçµç®—æ™‚æ­¸å°æ–¹
               for(let i=7; i<=12; i++) board[i] = 3;
               board[P1_STORE] = 10;
               board[P2_STORE] = 10;
               
               tutorialTarget = 5;
               showMessage("èª²ç¨‹ 4ï¼šçµæŸéŠæˆ²", 3000, "ä¸€æ–¹æ¸…ç©ºæ™‚éŠæˆ²çµæŸï¼Œå°æ‰‹å‰©é¤˜æ£‹å­æ­¸å°æ‰‹");
           }
           
           updateBoardUI();
           updateClickableState();
           updateTurnDisplay();
       }

       function nextTutorialStep() {
           tutorialStep++;
           if (tutorialStep > 4) {
               showMessage("æ•™å­¸å®Œæˆ", 2000, "ç¾åœ¨é–‹å§‹æ­£å¼éŠæˆ²");
               setTimeout(() => {
                   document.getElementById('mode-select').value = 'pve';
                   prepareGame();
               }, 2000);
           } else {
               setTimeout(() => {
                   setupTutorialStep(tutorialStep);
               }, 1500);
           }
       }

       /* -------------- éŠæˆ²æ ¸å¿ƒ -------------- */

       function startGameWithPlayer(starter) {
           if (isAnimating) return;

           document.getElementById('turn-selection-modal').style.display = 'none';
           activeGameDifficulty = aiDifficulty;

           board = Array(TOTAL_PITS).fill(INITIAL_SEEDS);
           board[P1_STORE] = 0;
           board[P2_STORE] = 0;
           currentPlayer = starter;
           gameActive = true;
           isAnimating = false;
           historyStack = [];
           
           document.getElementById('label-p1').innerText = "ç©å®¶ 1";
           let npcName = "é›»è…¦";
           if (gameMode === 'pve') {
               if (activeGameDifficulty === 'easy') npcName = "ç°¡å–®é›»è…¦";
               else if (activeGameDifficulty === 'normal') npcName = "æ™®é€šé›»è…¦";
               else if (activeGameDifficulty === 'hard') npcName = "å›°é›£é›»è…¦";
               else if (activeGameDifficulty === 'expert') npcName = "å°ˆå®¶é›»è…¦";
               else if (activeGameDifficulty === 'special') npcName = "ç‰¹åˆ¥é›»è…¦";
           } else {
               npcName = "ç©å®¶ 2";
           }
           document.getElementById('label-p2').innerText = npcName;
           
           const turnDisplay = document.getElementById('turn-display');
           turnDisplay.innerText = "éŠæˆ²æº–å‚™ä¸­"; // é‡ç½®æ–‡å­—
           turnDisplay.classList.add('active');

           updateBoardUI();
           updateTurnDisplay();
           updateControlsState(); 
           updateClickableState();
           hideNpcBubble();

           let starterName = "";
           if (gameMode === 'pve') {
               starterName = starter === 1 ? "ç©å®¶å…ˆæ‰‹" : "é›»è…¦å…ˆæ‰‹";
           } else {
               starterName = starter === 1 ? "ç©å®¶ 1 å…ˆæ‰‹" : "ç©å®¶ 2 å…ˆæ‰‹";
           }
           
           showMessage("éŠæˆ²é–‹å§‹", 1500, starterName);

           if (gameMode === 'pve' && currentPlayer === 2) {
               setTimeout(npcLogic, 1500);
           }
       }

       function saveState() {
           if (gameMode === 'tutorial') return; // æ•™å­¸ä¸ç´€éŒ„
           const state = JSON.stringify({ board: board, currentPlayer: currentPlayer });
           historyStack.push(state);
           updateControlsState();
       }

       function undoMove() {
           if (isAnimating || !gameActive || historyStack.length === 0 || gameMode === 'tutorial') return;

           const previousState = JSON.parse(historyStack.pop());
           board = previousState.board;
           currentPlayer = previousState.currentPlayer;

           updateBoardUI();
           updateTurnDisplay();
           updateClickableState();
           updateControlsState();
           showMessage("å›åˆ°ä¸Šä¸€æ­¥", 800);
       }

       function updateControlsState() {
           const undoBtn = document.getElementById('undo-btn');
           const resetBtn = document.getElementById('reset-btn');
           const modeSelect = document.getElementById('mode-select');
           const diffSelect = document.getElementById('difficulty-select');
           const turnSelectionBtns = document.querySelectorAll('#turn-selection-modal .btn');
           const tutorialBtn = document.getElementById('start-tutorial-btn');

           // å‹•ç•«ä¸­ç¦ç”¨æ•™å­¸æŒ‰éˆ•
           if (tutorialBtn) tutorialBtn.disabled = isAnimating;

           if (isAnimating || gameMode === 'tutorial') {
               undoBtn.disabled = true;
               resetBtn.disabled = true;
               modeSelect.disabled = true;
               diffSelect.disabled = true;
               turnSelectionBtns.forEach(btn => btn.disabled = true);
               
               // æ•™å­¸æ¨¡å¼ä¸‹å…è¨±é‡ç½®æŒ‰éˆ•ä½œç‚ºã€Œé€€å‡ºæ•™å­¸ã€
               if (gameMode === 'tutorial' && !isAnimating) {
                   resetBtn.disabled = false;
                   resetBtn.querySelector('span').innerText = "é€€å‡º";
                   resetBtn.onclick = () => {
                       // é€€å‡ºæ™‚æ¸…ç©ºæ£‹ç›¤ä¸¦åœæ­¢éŠæˆ²
                       resetBtn.querySelector('span').innerText = "é‡ç½®";
                       resetBtn.onclick = prepareGame;
                       
                       gameMode = 'pve';
                       document.getElementById('mode-select').value = 'pve';
                       
                       // æ¸…ç©ºæ£‹ç›¤ (å…¨0)
                       board = Array(TOTAL_PITS).fill(0);
                       currentPlayer = 1;
                       gameActive = false;
                       historyStack = [];
                       
                       // æ¢å¾© UI ç‹€æ…‹
                       const turnDisplay = document.getElementById('turn-display');
                       turnDisplay.innerText = "éŠæˆ²æº–å‚™ä¸­";
                       turnDisplay.style.color = "#fff";
                       turnDisplay.style.borderColor = "#444";
                       
                       updateBoardUI();
                       updateControlsState();
                       updateClickableState(); 
                       
                       showMessage("å·²é€€å‡ºæ•™å­¸", 1500);
                   };
               }
           } else {
               undoBtn.disabled = historyStack.length === 0 || !gameActive;
               resetBtn.disabled = false;
               resetBtn.querySelector('span').innerText = "é‡ç½®";
               resetBtn.onclick = prepareGame;
               modeSelect.disabled = false;
               diffSelect.disabled = false;
               turnSelectionBtns.forEach(btn => btn.disabled = false);
           }
       }

       function handlePitClick(index) {
           if (!gameActive || isAnimating) return;
           
           // æ•™å­¸æ¨¡å¼ç‰¹æ®Šè™•ç†
           if (gameMode === 'tutorial') {
               if (tutorialPhase === 'free_move') {
                   // è‡ªç”±è¡Œå‹•éšæ®µï¼Œå…è¨±ç©å®¶é»æ“Šä»»æ„å·±æ–¹éç©ºæ´
                   if (index < 0 || index > 5 || board[index] === 0) {
                       // é€™è£¡ä¸éœ€è¦é¡¯ç¤ºéŒ¯èª¤ï¼Œæ¨™æº–é‚è¼¯æœƒæ“‹æ‰
                       if (board[index] === 0 && index >= 0 && index <= 5) showMessage("ä¸å¯é¸æ“‡ç©ºæ´", 800);
                       return;
                   }
               } else if (index !== tutorialTarget) {
                   showMessage("è«‹é»æ“Šäº®èµ·çš„æ´", 1000);
                   return;
               }
           }
           
           // PVEç¦æ­¢ç©å®¶é»æ“Š (7-12)
           if (gameMode === 'pve' && index >= 7 && index <= 12) return;

           if (currentPlayer === 1 && (index < 0 || index > 5)) return;
           if (currentPlayer === 2 && (index < 7 || index > 12)) return;
           
           if (board[index] === 0) {
               showMessage("ä¸å¯é¸æ“‡ç©ºæ´", 800);
               return;
           }

           saveState();
           playTurn(index);
       }

       async function playTurn(startIndex) {
           const currentPhase = tutorialPhase; // è¨˜éŒ„ç•¶å‰éšæ®µ
           isAnimating = true;
           updateClickableState(); 
           updateControlsState(); 

           let seeds = board[startIndex];
           board[startIndex] = 0;
           updatePitUI(startIndex);
           
           let currentIndex = startIndex;
           
           for (let i = 0; i < seeds; i++) {
               currentIndex = (currentIndex + 1) % TOTAL_PITS;
               // è·³éå°æ‰‹è¨ˆåˆ†æ´
               if (currentPlayer === 1 && currentIndex === P2_STORE) {
                   currentIndex = (currentIndex + 1) % TOTAL_PITS;
               } else if (currentPlayer === 2 && currentIndex === P1_STORE) {
                   currentIndex = (currentIndex + 1) % TOTAL_PITS;
               }

               await animateSeedTransfer(startIndex, currentIndex);
               board[currentIndex]++;
               updatePitUI(currentIndex);
           }

           // æ•ç²é‚è¼¯
           let captured = false;
           const isMySide = (currentPlayer === 1 && currentIndex >= 0 && currentIndex <= 5) ||
                            (currentPlayer === 2 && currentIndex >= 7 && currentIndex <= 12);
           
           if (isMySide && board[currentIndex] === 1 && currentIndex !== P1_STORE && currentIndex !== P2_STORE) {
               const oppositeIndex = 12 - currentIndex;
               if (board[oppositeIndex] > 0) {
                   showMessage("æ•ç²", 1000, "å°æ‰‹æ£‹å­æ­¸ä½ ï¼");
                   highlightPit(currentIndex);
                   highlightPit(oppositeIndex);
                   await new Promise(r => setTimeout(r, 600));

                   const myStore = currentPlayer === 1 ? P1_STORE : P2_STORE;
                   
                   await Promise.all([
                       animateSeedTransfer(oppositeIndex, myStore),
                       animateSeedTransfer(currentIndex, myStore)
                   ]);

                   const captureAmount = board[oppositeIndex] + board[currentIndex];
                   board[oppositeIndex] = 0;
                   board[currentIndex] = 0;
                   board[myStore] += captureAmount;
                   
                   updatePitUI(currentIndex);
                   updatePitUI(oppositeIndex);
                   updatePitUI(myStore);
                   captured = true;
               }
           }

           const landedInStore = (currentPlayer === 1 && currentIndex === P1_STORE) ||
                                 (currentPlayer === 2 && currentIndex === P2_STORE);

           // æª¢æŸ¥éŠæˆ²çµæŸ (ä½¿ç”¨å¸ƒæ—å€¼åˆ¤å®šï¼Œä¸åœ¨æ­¤è™•ç›´æ¥å‘¼å« cleanup)
           const isGameOver = checkGameOverCondition();

           if (isGameOver) {
               gameActive = false;
               await endGameCleanup(); // ç­‰å¾…çµç®—å‹•ç•«å®Œæˆ
               
               // æ•™å­¸æ¨¡å¼ï¼šèª²ç¨‹ 4 çµç®—å®Œå¾Œå»¶é²çµæŸ
               if (gameMode === 'tutorial' && tutorialStep === 4) {
                   setTimeout(nextTutorialStep, 2500);
               }
               return; // éŠæˆ²çµæŸï¼Œçµ‚æ­¢å¾ŒçºŒé‚è¼¯
           }

           if (gameActive) {
               if (landedInStore) {
                   // æ•™å­¸æ¨¡å¼èª²ç¨‹ 2 ç‰¹æ®Šè™•ç†
                   if (gameMode === 'tutorial' && tutorialStep === 2 && currentPhase !== 'free_move') {
                       showMessage("å†ä¾†ä¸€æ¬¡", 2000, "æœ€å¾Œä¸€é¡†è½å…¥è¨ˆåˆ†æ´ï¼Œç²å¾—é¡å¤–å›åˆ");
                       tutorialPhase = 'free_move';
                       
                       isAnimating = false;
                       updateClickableState(); // æ›´æ–°é«˜äº®ç‹€æ…‹ (å…¨é«”)
                       updateControlsState();
                       return; // ä¸åˆ‡æ›å›åˆï¼Œç­‰å¾…ç©å®¶å†æ¬¡è¡Œå‹•
                   } else {
                       showMessage("å†ä¾†ä¸€æ¬¡", 1000, "æœ€å¾Œä¸€é¡†è½å…¥è¨ˆåˆ†æ´");
                   }
               } else {
                   currentPlayer = currentPlayer === 1 ? 2 : 1;
               }
               
               updateTurnDisplay();
               isAnimating = false;
               updateClickableState();
               updateControlsState(); 
               
               if (gameMode === 'tutorial') {
                   // å¦‚æœè™•æ–¼è‡ªç”±è¡Œå‹•éšæ®µçµæŸ
                   if (tutorialStep === 2 && currentPhase === 'free_move') {
                       tutorialPhase = null;
                       nextTutorialStep();
                   } else if (tutorialStep === 1 || tutorialStep === 3) {
                       nextTutorialStep();
                   }
               } else if (gameMode === 'pve' && currentPlayer === 2 && gameActive) {
                   setTimeout(npcLogic, 1000);
               }
           } else {
               isAnimating = false;
               updateControlsState();
           }
       }

       /* ---------------- AI Helpers ---------------- */

        function simulateMove(currentBoard, player, moveIdx) {
            let simBoard = [...currentBoard];
            let seeds = simBoard[moveIdx];
            simBoard[moveIdx] = 0;
            let currentIdx = moveIdx;
            
            const myStore = player === 1 ? P1_STORE : P2_STORE;
            const oppStore = player === 1 ? P2_STORE : P1_STORE;

            for(let i=0; i<seeds; i++) {
                currentIdx = (currentIdx + 1) % 14;
                if (currentIdx === oppStore) currentIdx = (currentIdx + 1) % 14;
                simBoard[currentIdx]++;
            }

            const isMySide = (player === 1 && currentIdx >= 0 && currentIdx <= 5) ||
                             (player === 2 && currentIdx >= 7 && currentIdx <= 12);
            
            if (isMySide && simBoard[currentIdx] === 1 && currentIdx !== P1_STORE && currentIdx !== P2_STORE) {
                const oppIdx = 12 - currentIdx;
                if (simBoard[oppIdx] > 0) {
                    simBoard[myStore] += (simBoard[oppIdx] + 1);
                    simBoard[oppIdx] = 0;
                    simBoard[currentIdx] = 0;
                }
            }

            let nextPlayer = player;
            if (currentIdx !== myStore) {
                nextPlayer = player === 1 ? 2 : 1;
            }

            return { board: simBoard, nextPlayer: nextPlayer };
        }

        function totalSeedsInPlay() {
            return board.slice(0, 6).concat(board.slice(7, 13)).reduce((a, b) => a + b, 0);
        }

        function isEndgame() {
            return totalSeedsInPlay() <= 12;
        }
        
        function calculateTempoAdvantage(moveIdx) {
            const result = simulateMove(board, 2, moveIdx);
            let freeTurnOps = 0;
            if (result.nextPlayer === 2) freeTurnOps += 1;
            
            for (let i = 7; i <= 12; i++) {
                if (result.board[i] > 0) {
                     let seeds = result.board[i];
                     let tempIdx = i;
                     for(let k=0; k<seeds; k++) {
                         tempIdx = (tempIdx + 1) % 14;
                         if(tempIdx === P1_STORE) tempIdx = (tempIdx + 1) % 14;
                     }
                     if (tempIdx === P2_STORE) freeTurnOps++;
                }
            }
            return freeTurnOps;
        }

        function getOpeningMove() {
            if (board[12] === 1 && board[13] === 0) return 12; 
            if (board[9] === 4) {
                 let res = simulateMove(board, 2, 9);
                 if (res.nextPlayer === 2) return 9;
            }
            return null;
        }

        function findBestEndgameMove(validMoves) {
            let bestMove = -1;
            let maxDiff = -Infinity;
            
            for (let move of validMoves) {
                let res = simulateMove(board, 2, move);
                let diff = res.board[P2_STORE] - res.board[P1_STORE];
                if (diff > maxDiff) {
                    maxDiff = diff;
                    bestMove = move;
                }
            }
            return bestMove;
        }


        /* ---------------- Expert AI Core ---------------- */
        
        function expertConditionalAI(validMoves) {
            if (validMoves.length === 1) return validMoves[0];
            
            const totalMovesMade = historyStack.length;
            if (totalMovesMade < 8) {
                const openingMove = getOpeningMove();
                if (openingMove !== null && validMoves.includes(openingMove)) return openingMove;
            }
            
            if (isEndgame()) {
                return findBestEndgameMove(validMoves);
            }
            
            const scoredMoves = validMoves.map(move => {
                let score = 0;
                
                score += board[move] * 0.1; 
                
                const result = simulateMove(board, 2, move);
                
                score += (result.board[13] - board[13]) * 3;
                
                if (result.nextPlayer === 2) {
                    score += 5 + (48 - totalSeedsInPlay()) * 0.1;
                }
                
                score += calculateTempoAdvantage(move) * 0.8;
                
                let opponentThreat = 0;
                if (result.nextPlayer === 1) {
                    for (let i = 0; i <= 5; i++) {
                        if (result.board[i] > 0) {
                            const oppResult = simulateMove(result.board, 1, i);
                            let threat = oppResult.board[6] - result.board[6];
                            if (oppResult.nextPlayer === 1) threat += 2;
                            opponentThreat = Math.max(opponentThreat, threat);
                        }
                    }
                }
                score -= opponentThreat * 1.5;
                
                let futurePotential = 0;
                for (let i = 7; i <= 12; i++) {
                    if (result.board[i] === 0) {
                        const opposite = 12 - i;
                        if (opposite >= 0 && opposite <= 5 && result.board[opposite] > 0) {
                            futurePotential += 2; 
                        }
                    }
                }
                score += futurePotential;
                
                const distToStore = 12 - move;
                const positionMetric = distToStore / 5; 
                
                const gamePhase = totalSeedsInPlay() / 48; 
                
                if (gamePhase > 0.6) {
                    score += positionMetric * 2; 
                } else if (gamePhase < 0.4) {
                    score += (1 - positionMetric) * 2;
                }
                
                return { move, score };
            });
            
            scoredMoves.sort((a, b) => b.score - a.score);
            
            if (scoredMoves.length >= 2 && scoredMoves[0].score > 0) {
                const diff = scoredMoves[0].score - scoredMoves[1].score;
                if (diff < (Math.abs(scoredMoves[0].score) * 0.1)) {
                     return Math.random() < 0.6 ? scoredMoves[0].move : scoredMoves[1].move;
                }
            }
            
            return scoredMoves[0].move;
        }

        /* ---------------- Special AI (Minimax) Core ---------------- */

        function getSpecialAIMove(initialBoard) {
            const MAX_DEPTH = 6;

            function getValidMovesForPlayer(boardState, player) {
                const moves = [];
                const start = player === 1 ? 0 : 7;
                const end = player === 1 ? 5 : 12;
                for (let i = start; i <= end; i++) {
                    if (boardState[i] > 0) moves.push(i);
                }
                moves.sort((a, b) => boardState[b] - boardState[a]); 
                return moves;
            }

            function evaluate(boardState) {
                return (boardState[P2_STORE] - boardState[P1_STORE]) * 100;
            }
            
            function checkTerminalAndScore(boardState) {
                let p1Empty = true;
                let p2Empty = true;
                for (let i = 0; i <= 5; i++) if (boardState[i] > 0) p1Empty = false;
                for (let i = 7; i <= 12; i++) if (boardState[i] > 0) p2Empty = false;

                if (p1Empty || p2Empty) {
                    let tempBoard = [...boardState];
                    for (let i = 0; i <= 5; i++) tempBoard[P1_STORE] += tempBoard[i];
                    for (let i = 7; i <= 12; i++) tempBoard[P2_STORE] += tempBoard[i];
                    
                    return (tempBoard[P2_STORE] - tempBoard[P1_STORE]) * 10000;
                }
                return null;
            }

            function minimax(boardState, depth, alpha, beta, isMaximizing) {
                const terminalScore = checkTerminalAndScore(boardState);
                if (terminalScore !== null) return terminalScore;
                
                if (depth === 0) return evaluate(boardState);

                if (isMaximizing) { 
                    let maxEval = -Infinity;
                    const moves = getValidMovesForPlayer(boardState, 2);
                    for (let move of moves) {
                        const sim = simulateMove(boardState, 2, move);
                        let eval;
                        if (sim.nextPlayer === 2) {
                            eval = minimax(sim.board, depth, alpha, beta, true);
                        } else {
                            eval = minimax(sim.board, depth - 1, alpha, beta, false);
                        }
                        
                        maxEval = Math.max(maxEval, eval);
                        alpha = Math.max(alpha, eval);
                        if (beta <= alpha) break; 
                    }
                    return maxEval;
                } else { 
                    let minEval = Infinity;
                    const moves = getValidMovesForPlayer(boardState, 1);
                    for (let move of moves) {
                        const sim = simulateMove(boardState, 1, move);
                        let eval;
                        if (sim.nextPlayer === 1) {
                            eval = minimax(sim.board, depth, alpha, beta, false);
                        } else {
                            eval = minimax(sim.board, depth - 1, alpha, beta, true);
                        }
                        
                        minEval = Math.min(minEval, eval);
                        beta = Math.min(beta, eval);
                        if (beta <= alpha) break;
                    }
                    return minEval;
                }
            }

            let bestMove = -1;
            let bestValue = -Infinity;
            const moves = getValidMovesForPlayer(initialBoard, 2);
            let alpha = -Infinity;
            let beta = Infinity;

            for (let move of moves) {
                const sim = simulateMove(initialBoard, 2, move);
                let moveValue;
                const rootTerminalScore = checkTerminalAndScore(sim.board);
                
                if (rootTerminalScore !== null) {
                    moveValue = rootTerminalScore;
                } else {
                    if (sim.nextPlayer === 2) {
                        moveValue = minimax(sim.board, MAX_DEPTH, alpha, beta, true);
                    } else {
                        moveValue = minimax(sim.board, MAX_DEPTH - 1, alpha, beta, false);
                    }
                }

                if (moveValue > bestValue) {
                    bestValue = moveValue;
                    bestMove = move;
                }
                alpha = Math.max(alpha, bestValue);
            }
            
            return bestMove !== -1 ? bestMove : moves[Math.floor(Math.random() * moves.length)];
        }


        /* ---------------- NPC Main Logic ---------------- */

        function isBadDefense(moveIdx) {
            let result = simulateMove(board, 2, moveIdx);
            if (result.nextPlayer === 1) {
                for(let i=0; i<=5; i++) {
                    if (result.board[i] > 0) {
                         let pResult = simulateMove(result.board, 1, i);
                         if (pResult.board[6] - result.board[6] > 2) return true;
                    }
                }
            }
            return false;
        }

        function npcLogic() {
            if (!gameActive || currentPlayer !== 2) return;
            isAnimating = true;
            updateControlsState();

            if (activeGameDifficulty === 'special') {
                const chosenMove = getSpecialAIMove(board);
                isAnimating = false;
                if (chosenMove !== -1) playTurn(chosenMove);
                return;
            }

            const validMoves = [];
            for (let i = 7; i <= 12; i++) {
                if (board[i] > 0) validMoves.push(i);
            }
            
            let chosenMove = -1;

            if (validMoves.length > 0) {
                if (activeGameDifficulty === 'expert') {
                    chosenMove = expertConditionalAI(validMoves);
                } 
                else {
                    for (let move of validMoves) {
                        let sim = simulateMove(board, 2, move);
                        if (sim.nextPlayer === 2) { 
                            if (activeGameDifficulty === 'hard' && isBadDefense(move)) continue;
                            chosenMove = move; 
                            break; 
                        }
                    }

                    if (chosenMove === -1 && activeGameDifficulty !== 'easy') {
                        for (let move of validMoves) {
                            let seeds = board[move];
                            let simPos = move;
                            for(let k=0; k<seeds; k++) {
                                simPos = (simPos + 1) % 14;
                                if (simPos === P1_STORE) simPos = (simPos + 1) % 14;
                            }
                            if (simPos >= 7 && simPos <= 12 && board[simPos] === 0 && simPos !== move) {
                                let opp = 12 - simPos;
                                if (board[opp] > 0) { 
                                    if (activeGameDifficulty === 'hard' && isBadDefense(move)) continue;
                                    chosenMove = move; 
                                    break; 
                                }
                            }
                        }
                    }
                    
                    if (chosenMove === -1) {
                        let pool = validMoves;
                        if (activeGameDifficulty === 'hard') {
                            let safeMoves = validMoves.filter(m => !isBadDefense(m));
                            if (safeMoves.length > 0) pool = safeMoves;
                        }
                        
                        let maxSeeds = -1;
                        for (let move of pool) {
                            if (board[move] > maxSeeds) { maxSeeds = board[move]; chosenMove = move; }
                        }
                    }
                }
            }
            
            isAnimating = false;
            if (chosenMove !== -1) playTurn(chosenMove);
        }

       /* ---------------- Helpers ---------------- */

       function highlightPit(index) {
           const el = document.querySelector(`.pit[data-id="${index}"]`);
           if(el) {
               el.classList.add('capture-flash');
               setTimeout(() => el.classList.remove('capture-flash'), 600);
           }
       }

       // åƒ…æª¢æŸ¥æ¢ä»¶ï¼Œä¸ç›´æ¥è§¸ç™¼çµæŸé‚è¼¯
       function checkGameOverCondition() {
           let p1Empty = true;
           let p2Empty = true;
           for (let i = 0; i <= 5; i++) if (board[i] > 0) p1Empty = false;
           for (let i = 7; i <= 12; i++) if (board[i] > 0) p2Empty = false;
           return p1Empty || p2Empty;
       }

       async function endGameCleanup() {
           isAnimating = true;
           updateControlsState();
           updateClickableState(); 
           
           // ä¿®å¾©ï¼šå¦‚æœæ˜¯æ•™å­¸æ¨¡å¼ç¬¬å››é—œï¼Œä¹Ÿé¡¯ç¤ºçµæŸéŠæˆ²æç¤º
           if (gameMode !== 'tutorial' || (gameMode === 'tutorial' && tutorialStep === 4)) {
               showMessage("éŠæˆ²çµæŸ", 3000, "ç§»å‹•å‰©ä¸‹çš„æ£‹å­");
           }

           const animations = [];
           const slowDuration = 1200; 
           
           for (let i = 0; i <= 5; i++) {
               if (board[i] > 0) {
                   animations.push(animateSeedTransfer(i, P1_STORE, slowDuration));
                   board[P1_STORE] += board[i];
                   board[i] = 0;
               }
           }
           for (let i = 7; i <= 12; i++) {
               if (board[i] > 0) {
                   animations.push(animateSeedTransfer(i, P2_STORE, slowDuration));
                   board[P2_STORE] += board[i];
                   board[i] = 0;
               }
           }

           if (animations.length > 0) await Promise.all(animations);

           updateBoardUI();

           if (gameMode === 'tutorial') {
                // æ•™å­¸æ¨¡å¼çµæŸå¾Œï¼Œå°‡å‹•ç•«ç‹€æ…‹è¨­ç‚ºfalseï¼Œé¿å…æŒ‰éˆ•é–æ­»
                isAnimating = false;
                updateControlsState();
                return;
           }

           let score1 = board[P1_STORE];
           let score2 = board[P2_STORE];
           let msg = "";
           
            if (score1 > score2) msg = "ç©å®¶ 1 ç²å‹";
            else if (score2 > score1) msg = (gameMode === 'pve' ? "é›»è…¦" : "ç©å®¶ 2") + " ç²å‹";
            else msg = "å¹³å±€";

           await new Promise(r => setTimeout(r, 500));
           showMessage(msg + `<br><div style="font-size:0.4em; margin-top:10px">${score1} - ${score2}</div>`, 6000);
           
           const turnDisplay = document.getElementById('turn-display');
           turnDisplay.innerText = "éŠæˆ²çµæŸ";
           turnDisplay.style.color = '#fff';
           turnDisplay.style.borderColor = '#444';
           turnDisplay.classList.remove('active');

           isAnimating = false;
           updateControlsState();
       }

       function updateBoardUI() {
           for (let i = 0; i < TOTAL_PITS; i++) updatePitUI(i);
       }

       function updateTurnDisplay() {
           const el = document.getElementById('turn-display');
           if (!gameActive) return;
           
           if (gameMode === 'tutorial') {
                el.innerText = `æ•™å­¸èª²ç¨‹ ${tutorialStep}/4`;
                el.style.color = 'var(--neon-3)';
                el.style.borderColor = 'var(--neon-3)';
                return;
           }

           let text = "";
           let color = "";
           if (currentPlayer === 1) {
               text = "ç©å®¶ 1 è¡Œå‹•";
               color = "var(--neon-1)";
           } else {
               text = "é›»è…¦æ€è€ƒä¸­...";
               if(gameMode === 'pvp') text = "ç©å®¶ 2 è¡Œå‹•";
               color = "var(--neon-2)";
           }
           el.innerText = text;
           el.style.color = color;
           el.style.borderColor = color;
       }

       function updatePitUI(index) {
           let el;
           if (index === P1_STORE) el = document.getElementById('store-6');
           else if (index === P2_STORE) el = document.getElementById('store-13');
           else el = document.querySelector(`.pit[data-id="${index}"]`);
           if (!el) return;
           el.querySelector('.seed-count-badge').innerText = board[index];
           const container = el.querySelector('.seeds-container');
           container.innerHTML = '';
           const visualCount = Math.min(board[index], 16); 
           for (let k = 0; k < visualCount; k++) {
               const seed = document.createElement('div');
               seed.className = 'seed';
               container.appendChild(seed);
           }
       }

       function calculateWaveDelay(index) {
           const cycleDuration = 2000; 
           const now = Date.now();
           let waveOffset = 0;
           if (index <= 5) {
               waveOffset = (5 - index) * 300; 
           } else {
               waveOffset = (12 - index) * 300;
           }
           const negativeDelay = -((now + waveOffset) % cycleDuration);
           return `${negativeDelay}ms`;
       }

       function updateClickableState() {
           const p1Store = document.getElementById('store-6');
           const p2Store = document.getElementById('store-13');
           
           document.querySelectorAll('.pit').forEach(p => {
               p.classList.remove('active-turn-glow');
               p.classList.remove('tutorial-target');
               p.style.animationDelay = ''; 
           });

           if (currentPlayer === 1 && gameActive) {
               p1Store.classList.add('highlight-turn');
               p2Store.classList.remove('highlight-turn');
           } else if (currentPlayer === 2 && gameActive) {
               p2Store.classList.add('highlight-turn');
               p1Store.classList.remove('highlight-turn');
           } else {
               p1Store.classList.remove('highlight-turn');
               p2Store.classList.remove('highlight-turn');
           }

           document.querySelectorAll('.pit').forEach(pit => {
               pit.classList.remove('disabled');
               pit.style.cursor = 'pointer';
               pit.style.opacity = '1';
               
               const id = parseInt(pit.dataset.id);
               const isP1Pit = id >= 0 && id <= 5;
               const isP2Pit = id >= 7 && id <= 12;
               
               // è¨­å®šå‘¼å¸ç‡ˆ
               if (gameActive && !isAnimating) {
                   if ((currentPlayer === 1 && isP1Pit) || (currentPlayer === 2 && isP2Pit)) {
                       pit.classList.add('active-turn-glow');
                       pit.style.animationDelay = calculateWaveDelay(id);
                   }
                   
                   // æ•™å­¸æ¨¡å¼ï¼šå¼·åŠ›é«˜äº®ç›®æ¨™
                   if (gameMode === 'tutorial') {
                       if (tutorialPhase === 'free_move') {
                            // è‡ªç”±è¡Œå‹•ï¼šé«˜äº®æ‰€æœ‰å¯é»æ“Šçš„å·±æ–¹æ´
                            if (id >= 0 && id <= 5 && board[id] > 0) {
                                pit.classList.add('active-turn-glow');
                            }
                       } else if (id === tutorialTarget) {
                           pit.classList.add('tutorial-target');
                           pit.classList.remove('active-turn-glow'); 
                       }
                   }
               }

               if (isAnimating || !gameActive) {
                   pit.classList.add('disabled');
                   pit.style.cursor = 'default';
               } else if (currentPlayer === 1 && !isP1Pit) {
                   pit.classList.add('disabled');
                   pit.style.cursor = 'not-allowed';
               } else if (currentPlayer === 2 && !isP2Pit) {
                   pit.classList.add('disabled');
                   pit.style.cursor = 'not-allowed';
               }
               
               // æ•™å­¸æ¨¡å¼ï¼šéç›®æ¨™å…¨éƒ¨ç¦ç”¨
               if (gameMode === 'tutorial' && !pit.classList.contains('disabled')) {
                   if (tutorialPhase === 'free_move') {
                       // è‡ªç”±è¡Œå‹•ï¼šå…è¨±æ‰€æœ‰å·±æ–¹éç©ºæ´ï¼Œç„¡éœ€ç¦ç”¨
                   } else if (id !== tutorialTarget) {
                       pit.classList.add('disabled');
                       pit.style.cursor = 'not-allowed';
                       pit.style.opacity = '0.4';
                   }
               }
           });
       }

       function animateSeedTransfer(fromIdx, toIdx, duration = 300) {
           return new Promise(resolve => {
               const fromEl = getElementByIndex(fromIdx);
               const toEl = getElementByIndex(toIdx);
               if (!fromEl || !toEl) { resolve(); return; }

               const rect1 = fromEl.getBoundingClientRect();
               const rect2 = toEl.getBoundingClientRect();

               const flying = document.createElement('div');
               flying.className = 'flying-seed';
               
               const colors = ['var(--neon-1)', 'var(--neon-2)', 'var(--neon-3)'];
               const randColor = colors[Math.floor(Math.random() * colors.length)];
               flying.style.backgroundColor = randColor;
               flying.style.boxShadow = `0 0 10px ${randColor}`;
               
               flying.style.transition = `all ${duration}ms cubic-bezier(0.25, 0.46, 0.45, 0.94)`;

               const startX = rect1.left + rect1.width/2 - 7;
               const startY = rect1.top + rect1.height/2 - 7;
               
               flying.style.left = startX + 'px';
               flying.style.top = startY + 'px';

               document.body.appendChild(flying);
               flying.getBoundingClientRect();

               flying.style.left = (rect2.left + rect2.width/2 - 7) + 'px';
               flying.style.top = (rect2.top + rect2.height/2 - 7) + 'px';

               setTimeout(() => {
                   flying.remove();
                   resolve();
               }, duration);
           });
       }

       function getElementByIndex(index) {
           if (index === P1_STORE) return document.getElementById('store-6');
           if (index === P2_STORE) return document.getElementById('store-13');
           return document.querySelector(`.pit[data-id="${index}"]`);
       }

       let msgTimeout;
       function showMessage(text, duration, subtitle = "") {
           const el = document.getElementById('center-message');
           
           let content = text;
           if (subtitle) {
               content += `<div style="font-size: 0.4em; margin-top: 15px; color: #ccc; font-weight: normal; letter-spacing: 1px;">${subtitle}</div>`;
           }
           
           el.innerHTML = content;
           el.style.opacity = 1;
           clearTimeout(msgTimeout);
           if (duration > 0) {
               msgTimeout = setTimeout(() => {
                   el.style.opacity = 0;
               }, duration);
           }
       }

       function toggleRules() {
           const modal = document.getElementById('rules-modal');
           modal.style.display = modal.style.display === 'flex' ? 'none' : 'flex';
       }

       function hideNpcBubble() {
           const bubble = document.getElementById('npc-bubble');
           bubble.classList.remove('visible');
       }

       init();
   </script>
</body>
</html>