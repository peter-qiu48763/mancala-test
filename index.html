<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <link rel="manifest" href="manifest.json">

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon" href="icon-192.png">

    <script>
      if ("serviceWorker" in navigator) {
        navigator.serviceWorker.register("sw.js");
      }
    </script>

   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
   <title>æ’­æ£‹ Mancala Pro</title>
   <style>
       :root {
           --bg-color: #121212;
           --container-bg: #1e1e1e;
           --pit-bg: #2a2a2a;
           --pit-border: 2px solid #333;
           --neon-1: #00E5FF;
           --neon-2: #FF4081;
           --neon-3: #FFEA00;
           --text-color: #E0E0E0;
           --accent-color: #1e1e1e;
       }

       body {
           margin: 0;
           padding: 0;
           font-family: 'Noto Sans TC','Segoe UI', Roboto, "Microsoft JhengHei", sans-serif;
           background-color: var(--bg-color);
           color: var(--text-color);
           display: flex;
           justify-content: center;
           align-items: center;
           min-height: 100vh;
           overflow: hidden;
           user-select: none;
           -webkit-user-select: none;
           touch-action: manipulation;
           background-image: radial-gradient(circle at 10% 20%, rgba(124, 77, 255, 0.1) 0%, transparent 20%),
                             radial-gradient(circle at 90% 80%, rgba(0, 229, 255, 0.1) 0%, transparent 20%);
       }

       .game-container {
           position: relative;
           width: 95vw;
           max-width: 900px;
           background: var(--container-bg);
           border-radius: 30px;
           box-shadow: 0 30px 60px rgba(0,0,0,0.6);
           padding: 30px;
           display: flex;
           flex-direction: column;
           align-items: center;
           border: 1px solid #333;
           box-sizing: border-box;
       }

       .header {
           width: 100%;
           display: flex;
           justify-content: space-between;
           align-items: center;
           margin-bottom: 20px;
           z-index: 10;
       }

       .controls-left, .controls-right {
           display: flex;
           gap: 10px;
           flex-wrap: wrap;
       }

       .btn {
           background: rgba(255, 255, 255, 0.05);
           backdrop-filter: blur(10px);
           -webkit-backdrop-filter: blur(10px);
           border: 1px solid rgba(255, 255, 255, 0.1);
           color: var(--text-color);
           padding: 10px 15px;
           border-radius: 12px;
           cursor: pointer;
           font-weight: 600;
           transition: all 0.3s ease;
           display: flex;
           align-items: center;
           justify-content: center;
           box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
           text-shadow: 0 1px 2px rgba(0,0,0,0.8); 
           white-space: nowrap;
           font-size: 0.9rem;
       }

       .btn:hover:not(:disabled) {
           background: rgba(255, 255, 255, 0.15);
           border-color: rgba(255, 255, 255, 0.3);
           transform: translateY(-2px);
           box-shadow: 0 8px 15px rgba(0, 0, 0, 0.2);
           color: #fff;
       }

       .btn:disabled {
           opacity: 0.3;
           cursor: not-allowed;
           transform: none;
           background: rgba(0,0,0,0.2);
           box-shadow: none;
           border-color: #333;
       }

       /* ä¸‹æ‹‰é¸å–®æ¨£å¼å„ªåŒ– */
       select.btn {
           appearance: none;
           padding-right: 30px;
           background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23ffffff'%3E%3Cpath d='M7 10l5 5 5-5z'/%3E%3C/svg%3E");
           background-repeat: no-repeat;
           background-position: right 8px center;
           background-size: 16px;
       }
       select.btn option {
           background-color: #252525;
           color: #fff;
       }
       
       select#difficulty-select {
           border-color: rgba(255, 255, 255, 0.1); /* Default border */
           font-weight: bold;
       }

       .turn-indicator {
           font-size: 1.2rem;
           font-weight: bold;
           color: #fff;
           padding: 10px 30px;
           background: rgba(255, 255, 255, 0.03);
           backdrop-filter: blur(10px);
           border-radius: 50px;
           border: 1px solid rgba(255, 255, 255, 0.1);
           min-width: 150px;
           text-align: center;
           position: relative;
           overflow: hidden;
           box-shadow: 0 4px 15px rgba(0,0,0,0.2);
           transition: all 0.3s;
       }

       .turn-indicator::after {
           content: '';
           position: absolute;
           bottom: 0; left: 0; width: 100%; height: 2px;
           background: linear-gradient(90deg, transparent, var(--neon-1), var(--neon-2), transparent);
           transform: scaleX(0);
           transition: transform 0.4s ease;
       }

       .turn-indicator.active {
           border-color: rgba(255, 255, 255, 0.2);
       }
       .turn-indicator.active::after {
           transform: scaleX(1);
       }

       .board {
           display: flex;
           justify-content: space-between;
           align-items: stretch;
           background: #222;
           padding: 25px;
           border-radius: 30px;
           width: 100%;
           box-sizing: border-box;
           gap: 20px;
           position: relative;
       }

       .store {
           width: 100px;
           min-height: 180px;
           background: var(--pit-bg);
           border-radius: 25px;
           border: var(--pit-border);
           display: flex;
           flex-direction: column;
           justify-content: center;
           align-items: center;
           position: relative;
           transition: all 0.3s;
       }
       
       .store.highlight-turn {
           border-color: rgba(255, 255, 255, 0.5);
           box-shadow: 0 0 20px rgba(255, 255, 255, 0.05);
           background: #333;
       }

       .pits-area {
           flex: 1;
           display: flex;
           flex-direction: column;
           justify-content: space-between;
           gap: 25px;
       }

       .row {
           display: flex;
           justify-content: space-around;
           gap: 5px;
       }

       .pit {
           width: 80px;
           height: 80px;
           background: var(--pit-bg);
           border-radius: 50%;
           border: var(--pit-border);
           display: flex;
           justify-content: center;
           align-items: center;
           cursor: pointer;
           position: relative;
           transition: all 0.2s;
       }

       /* å‘¼å¸ç‡ˆå‹•ç•« */
       @keyframes breathing-glow {
           0% { box-shadow: 0 0 0px rgba(255, 255, 255, 0); border-color: #333; }
           50% { box-shadow: 0 0 15px rgba(255, 255, 255, 0.4); border-color: rgba(255, 255, 255, 0.6); }
           100% { box-shadow: 0 0 0px rgba(255, 255, 255, 0); border-color: #333; }
       }

       /* ç•¶å‰å›åˆç©å®¶çš„å‘æ´ç™¼å…‰ Class */
       .pit.active-turn-glow {
           animation: breathing-glow 2s infinite ease-in-out;
           z-index: 5;
       }

       .pit:hover:not(.disabled) {
           background: #333;
           transform: translateY(-2px);
           border-color: var(--neon-1);
           box-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
       }
       
       .pit.capture-flash {
           animation: flashHighlight 0.5s ease !important; /* å¼·åˆ¶è¦†è“‹å‘¼å¸ç‡ˆ */
       }

       @keyframes flashHighlight {
           0% { background-color: var(--pit-bg); box-shadow: 0 0 0 transparent; }
           50% { background-color: #444; box-shadow: 0 0 20px var(--neon-2); border-color: var(--neon-2); }
           100% { background-color: var(--pit-bg); box-shadow: 0 0 0 transparent; }
       }

       .pit.disabled {
           cursor: default;
           opacity: 0.7;
           animation: none; /* ç¦ç”¨æ™‚ä¸ç™¼å…‰ */
       }

       .seed-count-badge {
           position: absolute;
           top: -8px;
           right: -8px;
           width: 26px;
           height: 26px;
           background: #3a3a3a;
           color: #fff;
           border-radius: 50%;
           font-size: 0.9rem;
           font-weight: bold;
           display: flex;
           justify-content: center;
           align-items: center;
           box-shadow: 0 2px 5px rgba(0,0,0,0.3);
           z-index: 6;
           border: 1px solid #555;
           transition: transform 0.2s;
       }
       
       .seeds-container {
           width: 65%;
           height: 65%;
           display: flex;
           flex-wrap: wrap;
           justify-content: center;
           align-items: center;
           gap: 4px;
           pointer-events: none;
       }

       .seed {
           width: 12px;
           height: 12px;
           border-radius: 50%;
           background-color: var(--neon-1);
           box-shadow: 0 0 4px rgba(0, 229, 255, 0.6); 
       }
       .seed:nth-child(2n) { background-color: var(--neon-2); box-shadow: 0 0 4px rgba(255, 64, 129, 0.6); }
       .seed:nth-child(3n) { background-color: var(--neon-3); box-shadow: 0 0 4px rgba(255, 234, 0, 0.6); }

       .label {
           position: absolute;
           color: #aaa;
           font-size: 0.85rem;
           text-transform: uppercase;
           letter-spacing: 1px;
           font-weight: 600;
           text-align: center;
           width: 100%;
       }
       .store.top .label { bottom: 15px; }
       .store.bottom .label { top: 15px; }

       #center-message {
           position: absolute;
           top: 50%;
           left: 50%;
           transform: translate(-50%, -50%);
           font-size: 3.5rem;
           color: #FFF;
           font-weight: 900;
           text-shadow: 0 4px 10px rgba(0,0,0,0.8);
           pointer-events: none;
           z-index: 100;
           opacity: 0;
           transition: opacity 0.3s;
           text-align: center;
           width: 100%;
           letter-spacing: 3px;
           white-space: nowrap;
       }

       .flying-seed {
           position: fixed;
           width: 14px;
           height: 14px;
           background-color: #fff;
           border-radius: 50%;
           z-index: 999;
           pointer-events: none;
           box-shadow: 0 0 10px #fff;
           transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
       }
       
       .ai-bubble {
           position: absolute;
           top: -60px;
           left: 50%;
           transform: translateX(-50%);
           background: rgba(0, 0, 0, 0.8);
           border: 1px solid var(--neon-2);
           color: var(--neon-2);
           padding: 10px 15px;
           border-radius: 15px;
           border-bottom-left-radius: 0;
           font-size: 0.9rem;
           min-width: 150px;
           text-align: center;
           box-shadow: 0 0 15px rgba(255, 64, 129, 0.3);
           opacity: 0;
           transition: opacity 0.5s;
           pointer-events: none;
           z-index: 50;
       }
       .ai-bubble.visible { opacity: 1; }

       .modal {
           display: none;
           position: fixed;
           top: 0; left: 0; width: 100%; height: 100%;
           background: rgba(0,0,0,0.85);
           backdrop-filter: blur(8px);
           z-index: 200;
           justify-content: center;
           align-items: center;
       }

       .modal-content {
           background: #252525;
           padding: 35px;
           border-radius: 20px;
           max-width: 500px;
           width: 90%;
           box-shadow: 0 10px 40px rgba(0,0,0,0.5);
           border: 1px solid #444;
           position: relative;
           color: #ddd;
           text-align: center;
       }

       .modal h2 {
           color: var(--neon-1);
           margin-top: 0;
           border-bottom: 1px solid #444;
           padding-bottom: 15px;
           margin-bottom: 20px;
           text-align: left;
       }
       
       .modal-content.centered-text h2 {
           text-align: center;
       }

       .close-btn {
           position: absolute;
           top: 15px;
           right: 20px;
           font-size: 28px;
           cursor: pointer;
           color: #888;
           transition: color 0.2s;
       }
       .close-btn:hover { color: #fff; }
       
       .selection-btn-container {
           display: flex;
           gap: 15px;
           justify-content: center;
           margin-top: 25px;
       }
       
       .selection-btn-container .btn {
           min-width: 120px;
           font-size: 1.1rem;
       }

       @media (max-width: 1024px) {
           .game-container { padding: 20px; width: 98vw; }
           .pit { width: 60px; height: 60px; }
           .store { width: 80px; }
       }

       @media (max-width: 768px) {
           .game-container { padding: 10px; border-radius: 15px; border: none; box-shadow: none; }
           .header { flex-direction: column; gap: 10px; margin-bottom: 10px; }
           .controls-left, .controls-right { width: 100%; justify-content: center; gap: 8px; }
           .turn-indicator { width: 90%; padding: 8px 10px; min-width: auto; font-size: 1rem; }
           .board { padding: 8px; gap: 5px; border-radius: 15px; }
           .pits-area { gap: 8px; }
           .pit { width: 11.5vw; height: 11.5vw; max-width: 50px; max-height: 50px; }
           .store { width: 13vw; max-width: 60px; min-height: auto; height: auto; border-radius: 15px; }
           .label { font-size: 0.7rem; }
           .seed { width: 6px; height: 6px; }
           .seed-count-badge { width: 18px; height: 18px; font-size: 0.7rem; }
           .btn { padding: 8px 12px; font-size: 0.85rem; border-radius: 10px; }
           #center-message { font-size: 2rem; white-space: normal; width: 90%; }
           .ai-bubble { top: auto; bottom: 110%; left: 0; transform: none; width: 150px; }
       }
   </style>
</head>
<body>

   <div class="game-container">
       <!-- é ‚éƒ¨è³‡è¨Šåˆ— -->
       <div class="header">
           <div class="controls-left">
               <button class="btn" onclick="toggleRules()">
                   <span style="font-size: 1em;">è¦å‰‡</span>
               </button>
               <select id="mode-select" class="btn" onchange="prepareGame()">
                   <option value="pve">å–®äººç·´ç¿’</option>
                   <option value="pvp">é›™äººå°æˆ°</option>
               </select>
               <!-- é›£åº¦é¸æ“‡ (åƒ… PVE é¡¯ç¤º) -->
               <select id="difficulty-select" class="btn" onchange="updateDifficultyStyle(); prepareGame()">
                   <option value="easy">é›£åº¦ï¼šç°¡å–®</option>
                   <option value="normal" selected>é›£åº¦ï¼šæ™®é€š</option>
                   <option value="hard">é›£åº¦ï¼šå›°é›£</option>
                   <option value="expert">é›£åº¦ï¼šå°ˆå®¶</option>
                   <option value="special">é›£åº¦ï¼šç‰¹åˆ¥</option>
               </select>
           </div>

           <div id="turn-display" class="turn-indicator active">
               éŠæˆ²æº–å‚™ä¸­
           </div>

           <div class="controls-right">
               <button id="undo-btn" class="btn" onclick="undoMove()" disabled>
                   <span style="font-size: 1em;">ä¸Šä¸€æ­¥</span>
               </button>
               <button id="reset-btn" class="btn" onclick="prepareGame()">
                   <span style="font-size: 1em;">é‡ç½®</span>
               </button>
           </div>
       </div>

       <!-- éŠæˆ²æ£‹ç›¤ -->
       <div class="board">
           <!-- ç©å®¶ 2 (NPC) çš„è¨ˆåˆ†æ´ -->
           <div class="store top" id="store-13">
               <div class="label" id="label-p2" style="top:15px;">é›»è…¦</div>
               <div class="seed-count-badge">0</div>
               <div class="seeds-container"></div>
               <!-- å°è©±æ°£æ³¡ -->
               <div id="npc-bubble" class="ai-bubble">example message</div>
           </div>

           <div class="pits-area">
               <!-- ç©å®¶ 2 çš„å‘æ´ (ä¸Šæ–¹ï¼Œç´¢å¼• 12 -> 7) -->
               <div class="row" id="row-p2">
                   <div class="pit" data-id="12"><div class="seed-count-badge">4</div><div class="seeds-container"></div></div>
                   <div class="pit" data-id="11"><div class="seed-count-badge">4</div><div class="seeds-container"></div></div>
                   <div class="pit" data-id="10"><div class="seed-count-badge">4</div><div class="seeds-container"></div></div>
                   <div class="pit" data-id="9"><div class="seed-count-badge">4</div><div class="seeds-container"></div></div>
                   <div class="pit" data-id="8"><div class="seed-count-badge">4</div><div class="seeds-container"></div></div>
                   <div class="pit" data-id="7"><div class="seed-count-badge">4</div><div class="seeds-container"></div></div>
               </div>

               <!-- ç©å®¶ 1 çš„å‘æ´ (ä¸‹æ–¹ï¼Œç´¢å¼• 0 -> 5) -->
               <div class="row" id="row-p1">
                   <div class="pit" data-id="0"><div class="seed-count-badge">4</div><div class="seeds-container"></div></div>
                   <div class="pit" data-id="1"><div class="seed-count-badge">4</div><div class="seeds-container"></div></div>
                   <div class="pit" data-id="2"><div class="seed-count-badge">4</div><div class="seeds-container"></div></div>
                   <div class="pit" data-id="3"><div class="seed-count-badge">4</div><div class="seeds-container"></div></div>
                   <div class="pit" data-id="4"><div class="seed-count-badge">4</div><div class="seeds-container"></div></div>
                   <div class="pit" data-id="5"><div class="seed-count-badge">4</div><div class="seeds-container"></div></div>
               </div>
           </div>

           <!-- ç©å®¶ 1 çš„è¨ˆåˆ†æ´ (å³å´) -->
           <div class="store bottom" id="store-6">
               <div class="label" id="label-p1" style="bottom:15px;">ç©å®¶ 1</div>
               <div class="seed-count-badge">0</div>
               <div class="seeds-container"></div>
           </div>
       </div>

       <div id="center-message"></div>
   </div>

   <!-- è¦å‰‡å½ˆçª— -->
   <div id="rules-modal" class="modal">
       <div class="modal-content">
           <span class="close-btn" onclick="toggleRules()">Ã—</span>
           <h2>ğŸ“– æ’­æ£‹ (Mancala) è¦å‰‡</h2>
           <p><strong>ç›®æ¨™ï¼š</strong> éŠæˆ²çµæŸæ™‚ï¼Œå·±æ–¹è¨ˆåˆ†æ´ï¼ˆå¤§æ´ï¼‰å…§çš„æ£‹å­æ¯”å°æ‰‹å¤šã€‚</p>
           <ul>
               <li><strong>ç§»å‹•ï¼š</strong> é»æ“Šå·±æ–¹å°æ´ï¼Œå–å‡ºæ‰€æœ‰æ£‹å­ï¼Œé€†æ™‚é‡ä¾åºæ’­æ’’ã€‚</li>
               <li><strong>è¨ˆåˆ†æ´ï¼š</strong> ç¶“éè‡ªå·±è¨ˆåˆ†æ´æ™‚æœƒæ”¾å…¥ä¸€é¡†ï¼Œç¶“éå°æ‰‹çš„å‰‡è·³éã€‚</li>
               <li><strong>å†ä¾†ä¸€æ¬¡ï¼š</strong> æœ€å¾Œä¸€é¡†è½å…¥è‡ªå·±çš„è¨ˆåˆ†æ´ï¼Œå¯é¡å¤–ç²å¾—ä¸€å›åˆã€‚</li>
               <li><strong>æ•ç²ï¼š</strong> æœ€å¾Œä¸€é¡†è½å…¥å·±æ–¹ç©ºæ´ä¸”å°é¢æœ‰æ£‹å­ï¼Œå…©é‚Šæ£‹å­éƒ½æ”¾å…¥å¤§æ´ã€‚</li>
               <li><strong>çµæŸï¼š</strong> ä¸€æ–¹æ¸…ç©ºæ‰€æœ‰å°æ´æ™‚çµæŸï¼Œå°æ‰‹å‰©é¤˜æ£‹å­æ­¸å°æ‰‹æ‰€æœ‰ã€‚</li>
           </ul>
       </div>
   </div>

   <!-- PVE å…ˆæ‰‹é¸æ“‡å½ˆçª— -->
   <div id="turn-selection-modal" class="modal">
       <div class="modal-content centered-text">
           <span class="close-btn" onclick="closeTurnSelection()">Ã—</span>
           <h2>èª°å…ˆé–‹å§‹ï¼Ÿ</h2>
           <div class="selection-btn-container">
               <button class="btn" onclick="startGameWithPlayer(1)">ç©å®¶å…ˆæ‰‹</button>
               <button class="btn" onclick="startGameWithPlayer(2)">é›»è…¦å…ˆæ‰‹</button>
           </div>
       </div>
   </div>

   <script>
       const TOTAL_PITS = 14;
       const P1_STORE = 6;
       const P2_STORE = 13;
       const INITIAL_SEEDS = 4;
       
       let board = [];
       let currentPlayer = 1;
       let gameActive = false;
       let isAnimating = false;
       let gameMode = 'pve';
       let aiDifficulty = 'normal';
       // è¿½è¹¤å¯¦éš›é›£åº¦ï¼Œå–æ¶ˆé¸æ“‡æ™‚å¾©åŸ
       let activeGameDifficulty = 'normal';
       let historyStack = [];

       function init() {
           document.querySelectorAll('.pit').forEach(pit => {
               pit.addEventListener('click', () => handlePitClick(parseInt(pit.dataset.id)));
           });
           updateDifficultyStyle(); 
           prepareGame(); 
       }
       
       function updateDifficultyStyle() {
           const select = document.getElementById('difficulty-select');
           const val = select.value;
           let color = '#fff';
           
           if (val === 'easy') color = '#2979FF';        // æ·±è—è‰²
           else if (val === 'normal') color = '#4CAF50'; // ç¶ è‰²
           else if (val === 'hard') color = '#FFC107';   // æ©˜é»ƒè‰²
           else if (val === 'expert') color = '#FF5252'; // ç´…è‰²
           else if (val === 'special') color = '#FF4081'; // æ¡ƒç´…è‰²
           
           select.style.color = color;
       }

       function prepareGame() {
           const modeSelector = document.getElementById('mode-select');
           const diffSelector = document.getElementById('difficulty-select');
           gameMode = modeSelector.value;
           aiDifficulty = diffSelector.value;
           
           diffSelector.style.display = gameMode === 'pve' ? 'block' : 'none';

           if (gameMode === 'pve') {
               document.getElementById('turn-selection-modal').style.display = 'flex';
               updateControlsState(); // æ›´æ–°æŒ‰éˆ•ç‹€æ…‹
           } else {
               const randomStarter = Math.random() < 0.5 ? 1 : 2;
               startGameWithPlayer(randomStarter);
           }
       }

       // é—œé–‰å…ˆæ‰‹é¸æ“‡æ™‚ï¼Œå¾©åŸé›£åº¦è¨­å®š
       function closeTurnSelection() {
           document.getElementById('turn-selection-modal').style.display = 'none';
           
           // å¦‚æœåªæ›é›£åº¦ä½†æ²’é–‹å§‹ï¼Œå°‡ UI å¾©åŸæˆå¯¦éš›é›£åº¦
           const diffSelector = document.getElementById('difficulty-select');
           if (diffSelector.value !== activeGameDifficulty) {
               diffSelector.value = activeGameDifficulty;
               aiDifficulty = activeGameDifficulty; // ç¢ºä¿é‚è¼¯è®Šæ•¸ä¹Ÿå¾©åŸ
               updateDifficultyStyle();
           }
       }

       function startGameWithPlayer(starter) {
           if (isAnimating) return; // å‹•ç•«ä¸­ç¦æ­¢é–‹å§‹

           document.getElementById('turn-selection-modal').style.display = 'none';
           
           // ç¢ºä¿é›£åº¦å·²æ›´æ–°
           activeGameDifficulty = aiDifficulty;

           board = Array(TOTAL_PITS).fill(INITIAL_SEEDS);
           board[P1_STORE] = 0;
           board[P2_STORE] = 0;
           currentPlayer = starter;
           gameActive = true;
           isAnimating = false;
           historyStack = [];
           
           document.getElementById('label-p1').innerText = "ç©å®¶ 1";
           let npcName = "é›»è…¦";
           if (gameMode === 'pve') {
               if (activeGameDifficulty === 'easy') npcName = "ç°¡å–®é›»è…¦";
               else if (activeGameDifficulty === 'normal') npcName = "æ™®é€šé›»è…¦";
               else if (activeGameDifficulty === 'hard') npcName = "å›°é›£é›»è…¦";
               else if (activeGameDifficulty === 'expert') npcName = "å°ˆå®¶é›»è…¦";
               else if (activeGameDifficulty === 'special') npcName = "ç‰¹åˆ¥é›»è…¦";
           } else {
               npcName = "ç©å®¶ 2";
           }
           document.getElementById('label-p2').innerText = npcName;
           
           const turnDisplay = document.getElementById('turn-display');
           turnDisplay.classList.add('active');

           updateBoardUI();
           updateTurnDisplay();
           updateControlsState(); 
           updateClickableState();
           hideNpcBubble();

           let starterName = "";
           if (gameMode === 'pve') {
               starterName = starter === 1 ? "ç©å®¶å…ˆæ‰‹" : "é›»è…¦å…ˆæ‰‹";
           } else {
               starterName = starter === 1 ? "ç©å®¶ 1 å…ˆæ‰‹" : "ç©å®¶ 2 å…ˆæ‰‹";
           }
           
           showMessage("éŠæˆ²é–‹å§‹", 1500, starterName);

           if (gameMode === 'pve' && currentPlayer === 2) {
               setTimeout(npcLogic, 1500);
           }
       }

       function saveState() {
           const state = JSON.stringify({ board: board, currentPlayer: currentPlayer });
           historyStack.push(state);
           updateControlsState();
       }

       function undoMove() {
           if (isAnimating || !gameActive || historyStack.length === 0) return;

           const previousState = JSON.parse(historyStack.pop());
           board = previousState.board;
           currentPlayer = previousState.currentPlayer;

           updateBoardUI();
           updateTurnDisplay();
           updateClickableState();
           updateControlsState();
           showMessage("å›åˆ°ä¸Šä¸€æ­¥", 800);
       }

       function updateControlsState() {
           const undoBtn = document.getElementById('undo-btn');
           const resetBtn = document.getElementById('reset-btn');
           const modeSelect = document.getElementById('mode-select');
           const diffSelect = document.getElementById('difficulty-select');
           
           // å…ˆæ‰‹é¸æ“‡è·³çª—å…§çš„æŒ‰éˆ•
           const turnSelectionBtns = document.querySelectorAll('#turn-selection-modal .btn');

           if (isAnimating) {
               undoBtn.disabled = true;
               resetBtn.disabled = true;
               modeSelect.disabled = true;
               diffSelect.disabled = true;
               turnSelectionBtns.forEach(btn => btn.disabled = true);
           } else {
               undoBtn.disabled = historyStack.length === 0 || !gameActive;
               resetBtn.disabled = false; 
               modeSelect.disabled = false;
               diffSelect.disabled = false;
               turnSelectionBtns.forEach(btn => btn.disabled = false);
           }
       }

       function handlePitClick(index) {
           if (!gameActive || isAnimating) return;
           
           // PVEç¦æ­¢ç©å®¶é»æ“Š (7-12)
           if (gameMode === 'pve' && index >= 7 && index <= 12) {
               return;
           }

           if (currentPlayer === 1 && (index < 0 || index > 5)) return;
           if (currentPlayer === 2 && (index < 7 || index > 12)) return;
           
           if (board[index] === 0) {
               showMessage("ä¸å¯é¸æ“‡ç©ºæ´", 800);
               return;
           }

           saveState();
           playTurn(index);
       }

       async function playTurn(startIndex) {
           isAnimating = true;
           updateClickableState(); 
           updateControlsState(); 

           let seeds = board[startIndex];
           board[startIndex] = 0;
           updatePitUI(startIndex);
           
           let currentIndex = startIndex;
           
           for (let i = 0; i < seeds; i++) {
               currentIndex = (currentIndex + 1) % TOTAL_PITS;
               if (currentPlayer === 1 && currentIndex === P2_STORE) {
                   currentIndex = (currentIndex + 1) % TOTAL_PITS;
               } else if (currentPlayer === 2 && currentIndex === P1_STORE) {
                   currentIndex = (currentIndex + 1) % TOTAL_PITS;
               }

               await animateSeedTransfer(startIndex, currentIndex);
               board[currentIndex]++;
               updatePitUI(currentIndex);
           }

           // æ•ç²
           let captured = false;
           const isMySide = (currentPlayer === 1 && currentIndex >= 0 && currentIndex <= 5) ||
                            (currentPlayer === 2 && currentIndex >= 7 && currentIndex <= 12);
           
           if (isMySide && board[currentIndex] === 1 && currentIndex !== P1_STORE && currentIndex !== P2_STORE) {
               const oppositeIndex = 12 - currentIndex;
               if (board[oppositeIndex] > 0) {
                   showMessage("æ•ç²", 1000, "å°æ‰‹æ£‹å­æ­¸ä½ ï¼");
                   highlightPit(currentIndex);
                   highlightPit(oppositeIndex);
                   await new Promise(r => setTimeout(r, 600));

                   const myStore = currentPlayer === 1 ? P1_STORE : P2_STORE;
                   
                   await Promise.all([
                       animateSeedTransfer(oppositeIndex, myStore),
                       animateSeedTransfer(currentIndex, myStore)
                   ]);

                   const captureAmount = board[oppositeIndex] + board[currentIndex];
                   board[oppositeIndex] = 0;
                   board[currentIndex] = 0;
                   board[myStore] += captureAmount;
                   
                   updatePitUI(currentIndex);
                   updatePitUI(oppositeIndex);
                   updatePitUI(myStore);
                   captured = true;
               }
           }

           const landedInStore = (currentPlayer === 1 && currentIndex === P1_STORE) ||
                                 (currentPlayer === 2 && currentIndex === P2_STORE);

           checkGameOver();

           if (gameActive) {
               if (landedInStore) {
                   showMessage("å†ä¾†ä¸€æ¬¡", 1000, "æœ€å¾Œä¸€é¡†è½å…¥è¨ˆåˆ†æ´");
               } else {
                   currentPlayer = currentPlayer === 1 ? 2 : 1;
               }
               
               updateTurnDisplay();
               isAnimating = false;
               updateClickableState();
               updateControlsState(); 

               if (gameMode === 'pve' && currentPlayer === 2 && gameActive) {
                   setTimeout(npcLogic, 1000);
               }
           } else {
               isAnimating = false;
               updateControlsState();
           }
       }

        /* ---------------- AI Helpers ---------------- */

        function simulateMove(currentBoard, player, moveIdx) {
            let simBoard = [...currentBoard];
            let seeds = simBoard[moveIdx];
            simBoard[moveIdx] = 0;
            let currentIdx = moveIdx;
            
            const myStore = player === 1 ? P1_STORE : P2_STORE;
            const oppStore = player === 1 ? P2_STORE : P1_STORE;

            for(let i=0; i<seeds; i++) {
                currentIdx = (currentIdx + 1) % 14;
                if (currentIdx === oppStore) currentIdx = (currentIdx + 1) % 14;
                simBoard[currentIdx]++;
            }

            const isMySide = (player === 1 && currentIdx >= 0 && currentIdx <= 5) ||
                             (player === 2 && currentIdx >= 7 && currentIdx <= 12);
            
            if (isMySide && simBoard[currentIdx] === 1 && currentIdx !== P1_STORE && currentIdx !== P2_STORE) {
                const oppIdx = 12 - currentIdx;
                if (simBoard[oppIdx] > 0) {
                    simBoard[myStore] += (simBoard[oppIdx] + 1);
                    simBoard[oppIdx] = 0;
                    simBoard[currentIdx] = 0;
                }
            }

            let nextPlayer = player;
            if (currentIdx !== myStore) {
                nextPlayer = player === 1 ? 2 : 1;
            }

            return { board: simBoard, nextPlayer: nextPlayer };
        }

        function totalSeedsInPlay() {
            return board.slice(0, 6).concat(board.slice(7, 13)).reduce((a, b) => a + b, 0);
        }

        function isEndgame() {
            return totalSeedsInPlay() <= 12;
        }
        
        function calculateTempoAdvantage(moveIdx) {
            const result = simulateMove(board, 2, moveIdx);
            let freeTurnOps = 0;
            if (result.nextPlayer === 2) freeTurnOps += 1;
            
            for (let i = 7; i <= 12; i++) {
                if (result.board[i] > 0) {
                     let seeds = result.board[i];
                     let tempIdx = i;
                     for(let k=0; k<seeds; k++) {
                         tempIdx = (tempIdx + 1) % 14;
                         if(tempIdx === P1_STORE) tempIdx = (tempIdx + 1) % 14;
                     }
                     if (tempIdx === P2_STORE) freeTurnOps++;
                }
            }
            return freeTurnOps;
        }

        function getOpeningMove() {
            if (board[12] === 1 && board[13] === 0) return 12; 
            if (board[9] === 4) {
                 let res = simulateMove(board, 2, 9);
                 if (res.nextPlayer === 2) return 9;
            }
            return null;
        }

        function findBestEndgameMove(validMoves) {
            let bestMove = -1;
            let maxDiff = -Infinity;
            
            for (let move of validMoves) {
                let res = simulateMove(board, 2, move);
                let diff = res.board[P2_STORE] - res.board[P1_STORE];
                if (diff > maxDiff) {
                    maxDiff = diff;
                    bestMove = move;
                }
            }
            return bestMove;
        }


        /* ---------------- Expert AI Core ---------------- */
        
        function expertConditionalAI(validMoves) {
            if (validMoves.length === 1) return validMoves[0];
            
            const totalMovesMade = historyStack.length;
            if (totalMovesMade < 8) {
                const openingMove = getOpeningMove();
                if (openingMove !== null && validMoves.includes(openingMove)) return openingMove;
            }
            
            if (isEndgame()) {
                return findBestEndgameMove(validMoves);
            }
            
            const scoredMoves = validMoves.map(move => {
                let score = 0;
                
                score += board[move] * 0.1; 
                
                const result = simulateMove(board, 2, move);
                
                score += (result.board[13] - board[13]) * 3;
                
                if (result.nextPlayer === 2) {
                    score += 5 + (48 - totalSeedsInPlay()) * 0.1;
                }
                
                score += calculateTempoAdvantage(move) * 0.8;
                
                let opponentThreat = 0;
                if (result.nextPlayer === 1) {
                    for (let i = 0; i <= 5; i++) {
                        if (result.board[i] > 0) {
                            const oppResult = simulateMove(result.board, 1, i);
                            let threat = oppResult.board[6] - result.board[6];
                            if (oppResult.nextPlayer === 1) threat += 2;
                            opponentThreat = Math.max(opponentThreat, threat);
                        }
                    }
                }
                score -= opponentThreat * 1.5;
                
                let futurePotential = 0;
                for (let i = 7; i <= 12; i++) {
                    if (result.board[i] === 0) {
                        const opposite = 12 - i;
                        if (opposite >= 0 && opposite <= 5 && result.board[opposite] > 0) {
                            futurePotential += 2; 
                        }
                    }
                }
                score += futurePotential;
                
                const distToStore = 12 - move;
                const positionMetric = distToStore / 5; 
                
                const gamePhase = totalSeedsInPlay() / 48; 
                
                if (gamePhase > 0.6) {
                    score += positionMetric * 2; 
                } else if (gamePhase < 0.4) {
                    score += (1 - positionMetric) * 2;
                }
                
                return { move, score };
            });
            
            scoredMoves.sort((a, b) => b.score - a.score);
            
            if (scoredMoves.length >= 2 && scoredMoves[0].score > 0) {
                const diff = scoredMoves[0].score - scoredMoves[1].score;
                if (diff < (Math.abs(scoredMoves[0].score) * 0.1)) {
                     return Math.random() < 0.6 ? scoredMoves[0].move : scoredMoves[1].move;
                }
            }
            
            return scoredMoves[0].move;
        }

        /* ---------------- Special AI (Minimax) Core ---------------- */

        function getSpecialAIMove(initialBoard) {
            // ä½¿ç”¨ Minimax + Alpha-Beta å‰ªæï¼Œæ·±åº¦ 6
            // è¦å‰‡ï¼šè‹¥ P1 ç©ºï¼ŒP2 çš„æ£‹å­æ­¸ P2 è¨ˆåˆ†æ´ã€‚è‹¥ P2 ç©ºï¼ŒP1 çš„æ£‹å­æ­¸ P1 è¨ˆåˆ†æ´ã€‚
            
            const MAX_DEPTH = 6;

            // è¼”åŠ©ï¼šå–å¾—æŸç©å®¶åˆæ³•æ­¥
            function getValidMovesForPlayer(boardState, player) {
                const moves = [];
                const start = player === 1 ? 0 : 7;
                const end = player === 1 ? 5 : 12;
                for (let i = start; i <= end; i++) {
                    if (boardState[i] > 0) moves.push(i);
                }
                // ç°¡å–®æ’åºå„ªåŒ–ï¼šè®“å¯èƒ½ç”¢ç”Ÿé€£é–çš„æ­¥å…ˆæœï¼Œæé«˜å‰ªææ•ˆç‡
                moves.sort((a, b) => boardState[b] - boardState[a]); 
                return moves;
            }

            // è¼”åŠ©ï¼šè©•ä¼°å‡½æ•¸
            function evaluate(boardState) {
                // åŸºæœ¬åˆ†æ•¸ï¼š(CPUåˆ†æ•¸ - ç©å®¶åˆ†æ•¸)
                return (boardState[P2_STORE] - boardState[P1_STORE]) * 100;
            }
            
            // è¼”åŠ©ï¼šæª¢æŸ¥æ˜¯å¦çµ‚å±€ä¸¦è¨ˆç®—æœ€çµ‚åˆ†æ•¸ (åŒ…å«æ¸…ç©ºé‚è¼¯)
            function checkTerminalAndScore(boardState) {
                let p1Empty = true;
                let p2Empty = true;
                for (let i = 0; i <= 5; i++) if (boardState[i] > 0) p1Empty = false;
                for (let i = 7; i <= 12; i++) if (boardState[i] > 0) p2Empty = false;

                if (p1Empty || p2Empty) {
                    // æ¨¡æ“¬çµ‚å±€æ¸…ç®—ï¼š
                    // è‹¥ä¸€æ–¹ç©ºï¼Œå‰‡å¦ä¸€æ–¹æ‰€æœ‰å‰©é¤˜æ£‹å­æ­¸å…¥è©²æ–¹è‡ªå·±çš„è¨ˆåˆ†æ´
                    let tempBoard = [...boardState];
                    for (let i = 0; i <= 5; i++) tempBoard[P1_STORE] += tempBoard[i]; // P1 å‰©çš„æ­¸ P1
                    for (let i = 7; i <= 12; i++) tempBoard[P2_STORE] += tempBoard[i]; // P2 å‰©çš„æ­¸ P2
                    
                    // å›å‚³çµ‚å±€åˆ†æ•¸ï¼Œä¸¦çµ¦äºˆæ¥µå¤§æ¬Šé‡ï¼Œç¢ºä¿ AI é‡è¦–å‹åˆ©
                    return (tempBoard[P2_STORE] - tempBoard[P1_STORE]) * 10000;
                }
                return null;
            }

            function minimax(boardState, depth, alpha, beta, isMaximizing) {
                // 1. æ¯ä¸€æ­¥éƒ½å…ˆæª¢æŸ¥æ˜¯å¦å·²ç¶“çµ‚å±€ (ä¸€æ–¹å…¨ç©º)
                const terminalScore = checkTerminalAndScore(boardState);
                if (terminalScore !== null) return terminalScore;
                
                // 2. è‹¥æœªçµ‚å±€ä½†é”åˆ°æ·±åº¦é™åˆ¶ï¼Œå›å‚³ç•¶å‰ç›¤é¢è©•ä¼°
                if (depth === 0) return evaluate(boardState);

                if (isMaximizing) { // CPU (P2)
                    let maxEval = -Infinity;
                    const moves = getValidMovesForPlayer(boardState, 2);
                    for (let move of moves) {
                        const sim = simulateMove(boardState, 2, move);
                        let eval;
                        // é—œéµé‚è¼¯ï¼šå¦‚æœæ˜¯ free turnï¼Œæ·±åº¦ä¸æ¸›
                        if (sim.nextPlayer === 2) {
                            eval = minimax(sim.board, depth, alpha, beta, true);
                        } else {
                            eval = minimax(sim.board, depth - 1, alpha, beta, false);
                        }
                        
                        maxEval = Math.max(maxEval, eval);
                        alpha = Math.max(alpha, eval);
                        if (beta <= alpha) break; // Alpha-Beta Pruning
                    }
                    return maxEval;
                } else { // Player (P1)
                    let minEval = Infinity;
                    const moves = getValidMovesForPlayer(boardState, 1);
                    for (let move of moves) {
                        const sim = simulateMove(boardState, 1, move);
                        let eval;
                        if (sim.nextPlayer === 1) {
                            eval = minimax(sim.board, depth, alpha, beta, false);
                        } else {
                            eval = minimax(sim.board, depth - 1, alpha, beta, true);
                        }
                        
                        minEval = Math.min(minEval, eval);
                        beta = Math.min(beta, eval);
                        if (beta <= alpha) break;
                    }
                    return minEval;
                }
            }

            // æ ¹ç¯€é»æœå°‹
            let bestMove = -1;
            let bestValue = -Infinity;
            const moves = getValidMovesForPlayer(initialBoard, 2);
            let alpha = -Infinity;
            let beta = Infinity;

            for (let move of moves) {
                const sim = simulateMove(initialBoard, 2, move);
                
                // æ³¨æ„ï¼šå³ä½¿æ˜¯æ ¹ç¯€é»çš„ç¬¬ä¸€æ­¥æ¨¡æ“¬ï¼Œä¹Ÿå¿…é ˆæª¢æŸ¥æ˜¯å¦å°è‡´çµ‚å±€
                // å› ç‚ºæœ‰å¯èƒ½é€™ä¸€æ­¥èµ°å®Œå°±æ¸…ç©ºäº†
                let moveValue;
                const rootTerminalScore = checkTerminalAndScore(sim.board);
                
                if (rootTerminalScore !== null) {
                    moveValue = rootTerminalScore;
                } else {
                    if (sim.nextPlayer === 2) {
                        moveValue = minimax(sim.board, MAX_DEPTH, alpha, beta, true);
                    } else {
                        moveValue = minimax(sim.board, MAX_DEPTH - 1, alpha, beta, false);
                    }
                }

                if (moveValue > bestValue) {
                    bestValue = moveValue;
                    bestMove = move;
                }
                alpha = Math.max(alpha, bestValue);
            }
            
            // å¦‚æœæ²’æ‰¾åˆ°å¥½æ­¥ (ç†è«–ä¸Šä¸è©²ç™¼ç”Ÿ)ï¼Œéš¨æ©Ÿå›å‚³
            return bestMove !== -1 ? bestMove : moves[Math.floor(Math.random() * moves.length)];
        }


        /* ---------------- NPC Main Logic ---------------- */

        function isBadDefense(moveIdx) {
            let result = simulateMove(board, 2, moveIdx);
            if (result.nextPlayer === 1) {
                for(let i=0; i<=5; i++) {
                    if (result.board[i] > 0) {
                         let pResult = simulateMove(result.board, 1, i);
                         if (pResult.board[6] - result.board[6] > 2) return true;
                    }
                }
            }
            return false;
        }

        function npcLogic() {
            if (!gameActive || currentPlayer !== 2) return;
            isAnimating = true;
            updateControlsState();

            // å¦‚æœæ˜¯ç‰¹åˆ¥é›£åº¦ï¼Œä½¿ç”¨ Minimax
            if (activeGameDifficulty === 'special') {
                const chosenMove = getSpecialAIMove(board);
                isAnimating = false;
                if (chosenMove !== -1) playTurn(chosenMove);
                return;
            }

            const validMoves = [];
            for (let i = 7; i <= 12; i++) {
                if (board[i] > 0) validMoves.push(i);
            }
            
            let chosenMove = -1;

            if (validMoves.length > 0) {
                if (activeGameDifficulty === 'expert') {
                    chosenMove = expertConditionalAI(validMoves);
                } 
                else {
                    for (let move of validMoves) {
                        let sim = simulateMove(board, 2, move);
                        if (sim.nextPlayer === 2) { 
                            if (activeGameDifficulty === 'hard' && isBadDefense(move)) continue;
                            chosenMove = move; 
                            break; 
                        }
                    }

                    if (chosenMove === -1 && activeGameDifficulty !== 'easy') {
                        for (let move of validMoves) {
                            let seeds = board[move];
                            let simPos = move;
                            for(let k=0; k<seeds; k++) {
                                simPos = (simPos + 1) % 14;
                                if (simPos === P1_STORE) simPos = (simPos + 1) % 14;
                            }
                            if (simPos >= 7 && simPos <= 12 && board[simPos] === 0 && simPos !== move) {
                                let opp = 12 - simPos;
                                if (board[opp] > 0) { 
                                    if (activeGameDifficulty === 'hard' && isBadDefense(move)) continue;
                                    chosenMove = move; 
                                    break; 
                                }
                            }
                        }
                    }
                    
                    if (chosenMove === -1) {
                        let pool = validMoves;
                        if (activeGameDifficulty === 'hard') {
                            let safeMoves = validMoves.filter(m => !isBadDefense(m));
                            if (safeMoves.length > 0) pool = safeMoves;
                        }
                        
                        let maxSeeds = -1;
                        for (let move of pool) {
                            if (board[move] > maxSeeds) { maxSeeds = board[move]; chosenMove = move; }
                        }
                    }
                }
            }
            
            isAnimating = false;
            if (chosenMove !== -1) playTurn(chosenMove);
        }

       /* ---------------- Helpers ---------------- */

       function highlightPit(index) {
           const el = document.querySelector(`.pit[data-id="${index}"]`);
           if(el) {
               el.classList.add('capture-flash');
               setTimeout(() => el.classList.remove('capture-flash'), 600);
           }
       }

       function checkGameOver() {
           let p1Empty = true;
           let p2Empty = true;
           for (let i = 0; i <= 5; i++) if (board[i] > 0) p1Empty = false;
           for (let i = 7; i <= 12; i++) if (board[i] > 0) p2Empty = false;

           if (p1Empty || p2Empty) {
               gameActive = false;
               endGameCleanup();
           }
       }

       async function endGameCleanup() {
           isAnimating = true;
           updateControlsState();
           updateClickableState(); // æ¸…é™¤å‘¼å¸ç‡ˆ
           
           // çµæŸæç¤º
           showMessage("éŠæˆ²çµæŸ", 3000, "ç§»å‹•å‰©ä¸‹çš„æ£‹å­");

           const animations = [];
           const slowDuration = 1200; 
           
           for (let i = 0; i <= 5; i++) {
               if (board[i] > 0) {
                   animations.push(animateSeedTransfer(i, P1_STORE, slowDuration));
                   board[P1_STORE] += board[i];
                   board[i] = 0;
               }
           }
           for (let i = 7; i <= 12; i++) {
               if (board[i] > 0) {
                   animations.push(animateSeedTransfer(i, P2_STORE, slowDuration));
                   board[P2_STORE] += board[i];
                   board[i] = 0;
               }
           }

           if (animations.length > 0) await Promise.all(animations);

           updateBoardUI();

           let score1 = board[P1_STORE];
           let score2 = board[P2_STORE];
           let msg = "";
           
            if (score1 > score2) msg = "ç©å®¶ 1 ç²å‹";
            else if (score2 > score1) msg = (gameMode === 'pve' ? "é›»è…¦" : "ç©å®¶ 2") + " ç²å‹";
            else msg = "å¹³å±€";

           await new Promise(r => setTimeout(r, 500));
           showMessage(msg + `<br><div style="font-size:0.4em; margin-top:10px">${score1} - ${score2}</div>`, 6000);
           
           const turnDisplay = document.getElementById('turn-display');
           turnDisplay.innerText = "éŠæˆ²çµæŸ";
           turnDisplay.style.color = '#fff';
           turnDisplay.style.borderColor = '#444';
           turnDisplay.classList.remove('active');

           isAnimating = false;
           updateControlsState();
       }

       function updateBoardUI() {
           for (let i = 0; i < TOTAL_PITS; i++) updatePitUI(i);
       }

       function updateTurnDisplay() {
           const el = document.getElementById('turn-display');
           if (!gameActive) return;
           
           let text = "";
           let color = "";
           if (currentPlayer === 1) {
               text = "ç©å®¶ 1 è¡Œå‹•";
               color = "var(--neon-1)";
           } else {
               text = "é›»è…¦æ€è€ƒä¸­...";
               if(gameMode === 'pvp') text = "ç©å®¶ 2 è¡Œå‹•";
               color = "var(--neon-2)";
           }
           el.innerText = text;
           el.style.color = color;
           el.style.borderColor = color;
       }

       function updatePitUI(index) {
           let el;
           if (index === P1_STORE) el = document.getElementById('store-6');
           else if (index === P2_STORE) el = document.getElementById('store-13');
           else el = document.querySelector(`.pit[data-id="${index}"]`);
           if (!el) return;
           el.querySelector('.seed-count-badge').innerText = board[index];
           const container = el.querySelector('.seeds-container');
           container.innerHTML = '';
           const visualCount = Math.min(board[index], 16); 
           for (let k = 0; k < visualCount; k++) {
               const seed = document.createElement('div');
               seed.className = 'seed';
               container.appendChild(seed);
           }
       }

       // æ–°å¢ï¼šè¨ˆç®—å‘¼å¸ç‡ˆæ³¢æµªæ•ˆæœçš„å‡½æ•¸
       // ä½¿ç”¨è² çš„ animationDelay é…åˆ Date.now()ï¼Œç¢ºä¿ç„¡è«–ä½•æ™‚åŠ å…¥ classï¼Œ
       // å‹•ç•«éƒ½æœƒèˆ‡å…¨åŸŸæ™‚é–“åŒæ­¥ï¼Œå½¢æˆç©©å®šçš„æ³¢æµªï¼Œä¸æœƒè¢« hover æˆ–å…¶ä»–é‡ç¹ªé‡ç½®ã€‚
       function calculateWaveDelay(index) {
           const cycleDuration = 2000; // å‹•ç•«é€±æœŸ 2ç§’
           const now = Date.now();
           
           // è¨ˆç®—åŸºç¤åç§»é‡ (æ³¢æµªå½¢ç‹€)
           let waveOffset = 0;
           if (index <= 5) {
               // P1: å·¦(0) -> å³(5)
               waveOffset = (5 - index) * 300; 
           } else {
               // P2: å³(7) -> å·¦(12) è¦–è¦ºä¸Š
               waveOffset = (12 - index) * 300;
           }

           // è¨ˆç®—è² å»¶é²ï¼šè®“å‹•ç•«çœ‹èµ·ä¾†å·²ç¶“é‹è¡Œäº†ä¸€æ®µæ™‚é–“
           // å…¬å¼ï¼š-( (ç•¶å‰æ™‚é–“ + æ³¢æµªåç§») % é€±æœŸ )
           // ä¿è­‰æ‰€æœ‰å…ƒç´ éƒ½å°é½Šæ™‚é–“è»¸
           const negativeDelay = -((now + waveOffset) % cycleDuration);
           
           return `${negativeDelay}ms`;
       }

       function updateClickableState() {
           const p1Store = document.getElementById('store-6');
           const p2Store = document.getElementById('store-13');
           
           // æ¸…é™¤æ‰€æœ‰å‘æ´çš„å‘¼å¸ç‡ˆæ•ˆæœ
           document.querySelectorAll('.pit').forEach(p => {
               p.classList.remove('active-turn-glow');
               // ç§»é™¤ inline style é¿å…å¹²æ“¾
               p.style.animationDelay = ''; 
           });

           if (currentPlayer === 1 && gameActive) {
               p1Store.classList.add('highlight-turn');
               p2Store.classList.remove('highlight-turn');
           } else if (currentPlayer === 2 && gameActive) {
               p2Store.classList.add('highlight-turn');
               p1Store.classList.remove('highlight-turn');
           } else {
               p1Store.classList.remove('highlight-turn');
               p2Store.classList.remove('highlight-turn');
           }

           document.querySelectorAll('.pit').forEach(pit => {
               pit.classList.remove('disabled');
               pit.style.cursor = 'pointer';
               pit.style.opacity = '1';
               
               const id = parseInt(pit.dataset.id);
               const isP1Pit = id >= 0 && id <= 5;
               const isP2Pit = id >= 7 && id <= 12;
               
               // è¨­å®šå‘¼å¸ç‡ˆï¼šä½¿ç”¨æ–°å‡½æ•¸è¨ˆç®—åŒæ­¥æ³¢æµª
               if (gameActive && !isAnimating) {
                   if ((currentPlayer === 1 && isP1Pit) || (currentPlayer === 2 && isP2Pit)) {
                       pit.classList.add('active-turn-glow');
                       pit.style.animationDelay = calculateWaveDelay(id);
                   }
               }

               if (isAnimating || !gameActive) {
                   pit.classList.add('disabled');
                   pit.style.cursor = 'default';
               } else if (currentPlayer === 1 && !isP1Pit) {
                   pit.classList.add('disabled');
                   pit.style.cursor = 'not-allowed';
               } else if (currentPlayer === 2 && !isP2Pit) {
                   pit.classList.add('disabled');
                   pit.style.cursor = 'not-allowed';
               }
           });
       }

       function animateSeedTransfer(fromIdx, toIdx, duration = 300) {
           return new Promise(resolve => {
               const fromEl = getElementByIndex(fromIdx);
               const toEl = getElementByIndex(toIdx);
               if (!fromEl || !toEl) { resolve(); return; }

               const rect1 = fromEl.getBoundingClientRect();
               const rect2 = toEl.getBoundingClientRect();

               const flying = document.createElement('div');
               flying.className = 'flying-seed';
               
               const colors = ['var(--neon-1)', 'var(--neon-2)', 'var(--neon-3)'];
               const randColor = colors[Math.floor(Math.random() * colors.length)];
               flying.style.backgroundColor = randColor;
               flying.style.boxShadow = `0 0 10px ${randColor}`;
               
               // è¨­å®šå‹•ç•«æ™‚é–“
               flying.style.transition = `all ${duration}ms cubic-bezier(0.25, 0.46, 0.45, 0.94)`;

               const startX = rect1.left + rect1.width/2 - 7;
               const startY = rect1.top + rect1.height/2 - 7;
               
               flying.style.left = startX + 'px';
               flying.style.top = startY + 'px';

               document.body.appendChild(flying);
               flying.getBoundingClientRect();

               flying.style.left = (rect2.left + rect2.width/2 - 7) + 'px';
               flying.style.top = (rect2.top + rect2.height/2 - 7) + 'px';

               setTimeout(() => {
                   flying.remove();
                   resolve();
               }, duration);
           });
       }

       function getElementByIndex(index) {
           if (index === P1_STORE) return document.getElementById('store-6');
           if (index === P2_STORE) return document.getElementById('store-13');
           return document.querySelector(`.pit[data-id="${index}"]`);
       }

       let msgTimeout;
       function showMessage(text, duration, subtitle = "") {
           const el = document.getElementById('center-message');
           
           let content = text;
           if (subtitle) {
               content += `<div style="font-size: 0.4em; margin-top: 15px; color: #ccc; font-weight: normal; letter-spacing: 1px;">${subtitle}</div>`;
           }
           
           el.innerHTML = content;
           el.style.opacity = 1;
           clearTimeout(msgTimeout);
           if (duration > 0) {
               msgTimeout = setTimeout(() => {
                   el.style.opacity = 0;
               }, duration);
           }
       }

       function toggleRules() {
           const modal = document.getElementById('rules-modal');
           modal.style.display = modal.style.display === 'flex' ? 'none' : 'flex';
       }

       function hideNpcBubble() {
           const bubble = document.getElementById('npc-bubble');
           bubble.classList.remove('visible');
       }

       init();
   </script>
</body>
</html>